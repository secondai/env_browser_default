[{"_id":"5a274fc39bd7021a55d5b61a","type":"external_identity:0.0.1:local:8982f982j92","data":{"publicKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAk8Ytv18WAt9OBd/ROdk6\nNxTRoVcIaT8hzQ5ZYBdxm70MDvFDi1QAqrDtbZQkRnzvLRv68wJDY0s34jA9SPcJ\nxUn0umfN6VZapjV5Vsw+DvzmsUYvcjXH+0GhSWcBUtbW7Y71vDsOwFei3g1lMEPA\ntKsk5xbC1791nqk2lb15NtWc7x1Md6sjxvNcL0MaNv1WkPWQDo5/TZ3L8qDhx087\nx7QuyzjnPlEuwLnMghi9DKmW8Agg5sCYcKwrCqAvcLF1j/4iy/2U6FTIcIBoYKnh\n/TSvqLvIcrdt5neL2jqvBbK/DQhN/qsP3GIiWe/kqaqWeoeYiu3Fnf+x2JDB+InN\nRwIDAQAB\n-----END PUBLIC KEY-----","commonName":"teacher"},"active":true,"createdAt":1512525763969,"updatedAt":1513140327191,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a274fc39bd7021a55d5b61c","nodeId":"5a274fc39bd7021a55d5b61a","type":"external_identity_connect_method:0.0.1:local:382989239hsdfmn","data":{"method":"http","connection":"http://teacher.second.ngrok.io/ai"},"active":true,"createdAt":1512525763973,"updatedAt":1513138321929,"parent":{"_id":"5a274fc39bd7021a55d5b61a","nodeId":"5a27846f9cb84d22ebce60ab","type":"external_identity:0.0.1:local:8982f982j92","data":{"publicKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAk8Ytv18WAt9OBd/ROdk6\nNxTRoVcIaT8hzQ5ZYBdxm70MDvFDi1QAqrDtbZQkRnzvLRv68wJDY0s34jA9SPcJ\nxUn0umfN6VZapjV5Vsw+DvzmsUYvcjXH+0GhSWcBUtbW7Y71vDsOwFei3g1lMEPA\ntKsk5xbC1791nqk2lb15NtWc7x1Md6sjxvNcL0MaNv1WkPWQDo5/TZ3L8qDhx087\nx7QuyzjnPlEuwLnMghi9DKmW8Agg5sCYcKwrCqAvcLF1j/4iy/2U6FTIcIBoYKnh\n/TSvqLvIcrdt5neL2jqvBbK/DQhN/qsP3GIiWe/kqaqWeoeYiu3Fnf+x2JDB+InN\nRwIDAQAB\n-----END PUBLIC KEY-----","commonName":"teacher"},"active":true,"createdAt":1512525763969,"updatedAt":1513140327191},"nodes":[]}]},{"_id":"5a2784709cb84d22ebce60bb","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1512539248165,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784719cb84d22ebce60cc","nodeId":"5a2784709cb84d22ebce60bb","type":"code:0.0.1:local:32498h32f2","data":{"key":"a9c55c9a-327f-46ba-938c-2237fba25eae","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: user_default\n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - first request (only seeded) \n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      switch(INPUT.type){\n        \n        case 'incoming_first:0.1.1:local:78882h37':\n        \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          \n          // Find remote Second \n          // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // - want a publicKey and a URL returned \n          //   - a whole IdentityNode should be returned? \n          // - return: \n          //   - external_identity:0.0.1:local:8982f982j92\n          //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          let remoteValue;\n          try {\n            remoteValue = WINDOW.prompt('Remote Second','test21 test21');\n          }catch(err){\n            console.error('Not in Tab');\n            remoteValue = 'test test';\n          }\n          \n          console.log('Words to use for ExternalIdentity:', remoteValue);\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words: remoteValue\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          // fetch that wallet address, get the first transaction \n          // - first transaction contains IPFS link \n          // - IPFS contains Nodes (without _ids!) \n          let foundExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('Got foundExternalIdentityNode',foundExternalIdentityNode);\n          \n          // Save ExternalIdentityNode locally! \n          let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'saveExternal',\n              options: {\n                ExternalIdentityNode: foundExternalIdentityNode // should contain a connection method! \n              }\n            }\n          });\n          \n          // Update local node commonName (for easy lookup) \n          ExternalIdentityNode.data.commonName = 'main';\n          let updatedExternal = await universe.updateNode(ExternalIdentityNode);\n          \n          \n          console.log('Saved new ExternalIdentityNode', ExternalIdentityNode);\n          \n          // await universe.newNode(ExternalIdentityNode);\n          \n          // return resolve({\n          //   ExternalIdentityNode,\n          //   error: true,\n          //   remoteValue,\n          //   address\n          // })\n          \n          \n          let internalUserPassphrase;\n          try {\n            internalUserPassphrase = WINDOW.prompt('Internal User Passphrase','');\n          }catch(err){\n            console.error('Not in Tab');\n            internalUserPassphrase = '';\n          }\n          \n          \n          \n          // Identify and Upgrade connection as an InternalUser (using passphrase) \n          // - this uses the newly-created ExternalIdentityNode user \n          // - also upgrades our local data.token \n          \n          try {\n            \n          // Authenticate with External Second \n          // - make authenticated requests to a Second (necessary for Learning?) \n          //   - should have ALL requests authenticated \n          // universe.setupExternalSecond();\n            \n            // Initiating Identify ...again\n            let authExternalIdentityNode2 = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" \n                }\n              }\n            });\n            \n            console.log('Finished IdentifyInitiate2. Starting IdentifyActAsInternalUser');\n          \n            let actAsNode = await universe.loadAndRunCapability('IdentifyActAsInternalUser',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  internalUserPassphrase\n                }\n              }\n            });\n            console.log('Finished Upgrading local identity with ActAs. actAsNode Response', actAsNode);\n            \n            \n            // Test new user (am I really ActAs?) \\\n            let e2Nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: ExternalIdentityNode.data.publicKey\n                  }\n                }\n              }\n            });\n            let e2node = e2Nodes[0];\n            \n            console.log('e2node:', e2node);\n            \n            let e2response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: e2node,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                              \n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: e2node.data.token\n                          }\n                        },\n                        \n                        // {\n                        //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                        //   dataForAction: {\n                        //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                        //     data: {}\n                        //   }\n                        // }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('e2response',e2response);\n            \n          }catch(err){\n            console.error('Failed actAsNode upgrade',err);\n          }\n          \n          \n          \n          return resolve({\n            externalResponse: true,\n            // response,\n            codeResultNode,\n            // localResult\n          })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n          \n          \n          break;\n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          // - expecting INPUT.type.data is a node! \n          // - might be actions, or something else \n            \n            \n          let nodes = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    // see if has a ChildNode matching a type \n                    let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                      return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                    })\n                    // 'run_action:0.0.1:local:2398y294c23'\n                    if(!foundMatcherChild){\n                      return false;\n                    }\n                    \n                    return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          if(nodes && nodes.length){\n            // found Node to run for action! \n  \n            let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n            \n            // run in vm, and pass in the inputSchema Node! \n            // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n            let actionResult;\n            try {\n              actionResult = await universe.runNodeCodeInVM({\n                codeNode,\n                dataNode: INPUT\n              });\n              \n              // ,{\n              //   codeNode, // includes type/schemaName and data \n              //   dataNode: INPUT, // should be another Node that can be used by the action! \n              //   timeout: 15 * 1000\n              // });\n            }catch(err){\n              return resolve('FAILED code from incoming_browser_request');\n            }\n            \n            // validate actionResult!\n            // - todo\n            \n            return resolve(actionResult);\n            // { \n            //   txt: 'Response:', \n            //   nodeTypes: nodes.map(n=>n.type),\n            //   actionResult\n            // }); // + result);\n            \n          } else {\n            // no Node found for handling action :( \n              \n            return resolve({ \n              error: 'No Nodes for action (incoming_browser_request)',\n              INPUT\n            }); // + result);\n          }\n          \n          \n          // switch(INPUT.data.type){\n            \n          //   case 'ping:0.0.1:local:239fh298fh239h23':\n          //     return resolve({\n          //       ping: 'pong'\n          //     });\n            \n          //   case 'browser_startup:0.0.1:local:8831167ssd':\n          //     // setting up initial component \n          //     let result = await universe.searchMemory({\n          //       filter: {\n          //         sqlFilter: {\n          //           type: 'react_component:0.0.1:local:98912hd89',\n          //           data: {\n          //             internalId: 'MainComponent'\n          //           }\n          //         }\n          //       }\n          //     });\n          //     let componentNode = await universe.runInVM(result[0],{});\n              \n          //     return resolve(componentNode);\n            \n          //   default:\n          //     break;\n          // }\n          \n          break;\n          \n          \n        default:\n          break;\n      }\n\n      return resolve({\n        type: 'err:..',\n        data: {\n          msg: 'Missing valid input type'\n        }\n      });\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539249438,"updatedAt":1513150330358,"parent":{"_id":"5a2784709cb84d22ebce60bb","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1512539248165,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784749cb84d22ebce60dc","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Storing 'browser_developer' UI here"},"active":true,"createdAt":1512539252192,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[]},{"_id":"5a2784759cb84d22ebce60ef","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784769cb84d22ebce60ff","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"3ae95ba5-2d74-4fa4-846d-768b503c398b","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            developerComponent: null,\n          }\n        }\n        \n        componentDidMount(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'DefaultLayout'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                defaultLayout: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'MainDeveloperComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                developerComponent: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'MainCommandsComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                commandsComponent: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'MainUserComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                userViewComponent: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n          });\n          \n        }\n        \n        render(){\n          \n          const DeveloperComponent = this.state.developerComponent || ErrorComponent;\n          const CommandsComponent = this.state.commandsComponent || ErrorComponent;\n          const UserViewComponent = this.state.userViewComponent || ErrorComponent;\n          const DefaultLayout = this.state.defaultLayout || ErrorComponent;\n          \n          return (\n            <Router>\n              <Switch>\n                <DefaultLayout exact path=\"/\" component={CommandsComponent}/>\n                <DefaultLayout exact path=\"/friends\" component={UserViewComponent}/>\n                <DefaultLayout exact path=\"/dev\" component={DeveloperComponent}/>\n              </Switch>\n            </Router>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"MainComponent"},"active":true,"createdAt":1512539254754,"updatedAt":1513153205041,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a2784779cb84d22ebce6110","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"e112ac57-d342-4d1e-ab6e-fe36f1ff32b7","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n                \n              let nodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    nodeId: null\n                  }\n                }\n              });\n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        render(){\n          return (\n            <div className=\"\">\n              {\n                this.state.nodes.map(node=>{\n                  return (\n                    <div key={node._id}>\n                      {node.type}\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"ListComponent"},"active":true,"createdAt":1512539255918,"updatedAt":1513153205561,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a2784799cb84d22ebce6120","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"internalId":"ListRemoteComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: [],\n            text: '',\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchRemoteNodes();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchRemoteNodes);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchRemoteNodes);\n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              this.props.setState({\n                OwnerSecondExternalIdentityNode: ExternalIdentityNode\n              });\n      \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n      \n        @autobind\n        handleNewNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        handleClickNode(node){\n          this.props.setState({\n            editingNode: node\n          })\n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        renderNodes(nodes, parentInFilter){\n          \n          let filter = this.state.text;\n          \n          nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          // console.log('Nodes',nodes);\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                \n                  const nodeMatchFunc = (node) => {\n                    let nodeMatch;\n                    if(node.type && node.type.includes(filter)){\n                      nodeMatch = true;\n                    }\n                    if(node.data && JSON.stringify(node.data).includes(filter)){\n                      nodeMatch = true;\n                    }\n                    // type (t:)\n                    if(filter.includes('t:') && node.type){\n                      let tmpFilter = filter.split('t:')[1];\n                      if(node.type && node.type.includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    // data (d:) \n                    if(filter.includes('d:')){\n                      let tmpFilter = filter.split('d:')[1];\n                      if(node.data && JSON.stringify(node.data).includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    \n                    return nodeMatch;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = filter.length ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  try {\n                    switch(node.type){\n                      case 'react_component:0.0.1:local:98912hd89':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn:0.0.1:local:2839fh29':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag:0.0.1:local:239fj23':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability:0.0.1:local:187h78h23':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code:0.0.1:local:32498h32f2':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity:0.0.1:local:8982f982j92':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method:0.0.1:local:382989239hsdfmn':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  return (\n                    <div key={node._id}>\n                      <div onClick={e=>this.handleClickNode(node)} style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                    \n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              {\n                                (this.props.state.editingNode && this.props.state.editingNode._id == node._id) ?\n                                  <strong>\n                                    {node.type}\n                                  </strong>\n                                  :\n                                  node.type\n                              }\n                            </div>\n                            {\n                              !tooltip ? '':\n                              <div className=\"tooltip\">\n                                {tooltip}\n                              </div>\n                            }\n                          </div>\n                          \n                      </div>\n                      {\n                        !(node.nodes && node.nodes.length) ? '':\n                        <div style={{paddingLeft:'8px'}}>\n                          {this.renderNodes(node.nodes, parentInFilter || nodeMatch)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\">\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button\" onClick={this.handleInsertNodePaste}>Save</button>\n                </div>\n              }\n              \n              <strong>\n                My Cloud Second Memory\n                &nbsp;\n                <button className=\"button is-small\" onClick={this.handleNewNode}>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-plus\"></i>\n                  </span>\n                </button>\n                &nbsp;\n                \n                <div className=\"dropdown is-hoverable is-right\">\n                  <div className=\"dropdown-trigger\">\n                    <button className=\"button is-small\">\n                      <span className=\"icon is-small\">\n                        <i className=\"fa fa-angle-down\"></i>\n                      </span>\n                    </button>\n                  </div>\n                  <div className=\"dropdown-menu\">\n                    <div className=\"dropdown-content\">\n                    \n                      <a className=\"dropdown-item\" onClick={this.handleEncryptString}>\n                        Encrypt String\n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={e=>this.setState({pastable:true})}>\n                        Insert Node By Paste\n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={this.handleAddMany}>\n                        Insert Many for Test\n                      </a>\n                      \n                    </div>\n                  </div>\n                </div>\n                \n              </strong>\n              \n              \n              <div>\n                <input className=\"input\" value={this.state.text} onChange={e=>this.setState({text:e.target.value})} placeholder=\"Filter on type/data\" />\n              </div>\n              \n              {this.renderNodes(nodes)}\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","key":"786f3c96-22fb-4904-8fd8-9feba20c7fc5"},"active":true,"createdAt":1512539257216,"updatedAt":1513209319158,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a27847a9cb84d22ebce6132","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"aa7edc35-5d30-4f90-81a3-9afdecd83e0d","internalId":"ListRemoteConnectedToComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // Imports\n      const { ContextMenu, MenuItem, ContextMenuTrigger } = universe.ReactContextMenu;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n          this.fetchRemoteNodes();\n          \n          universe.EE.on('nodes-modified', this.fetchRemoteNodes);\n        \n        }\n        \n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchRemoteNodes);\n        }\n        \n        componentWillReceiveProps(nextProps){\n          console.log('Friends componentWillReceiveProps:', nextProps);\n          this.fetchRemoteNodes();\n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n          \n          console.log('Fetching remote Nodes');\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n            \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            console.log('Fetching for', ExternalIdentityNode);\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != 'external_identity:0.0.1:local:8982f982j92'){\n                                        return false;\n                                      }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleClick(ExternalIdentityNode){\n          console.log('Clicked ExternalIdentityNode');\n          this.props.setState({\n            ExternalIdentityNode \n          });\n        }\n        \n        @autobind\n        handleContextClick(e, data){\n          // console.log('Clicked ExternalIdentityNode');\n          // this.props.setState({\n          //   ExternalIdentityNode \n          // });\n          console.log('Clicked:', data);\n        }\n        \n        @autobind\n        async handleAddFriend(){\n          let words = WINDOW.prompt('Words for address:','test17 test17');\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          console.log('Address:', address);\n          \n          let Friend_ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('MySecond:', this.props.state.OwnerSecondExternalIdentityNode);\n          console.log('FriendSecond', Friend_ExternalIdentityNode);\n          \n          \n          // Make TalkToSecond request to Identity MySecond with remote \n          let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                      {\n                        matchActionType: 'identify_challenge_initiate:0.0.1:local:8239hf28hf283h',\n                        dataForAction: {\n                          type: 'challenge_init_remote:0.0.1:...',\n                          data: {\n                            ExternalIdentityNode: Friend_ExternalIdentityNode\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('Friend Connection Response:', response);\n          \n        }\n        \n        @autobind\n        handleClickNode(friendNode){\n        }\n        \n        @autobind\n        handleChangeGroup(e, data){\n          // Add/update existing group info \n          return new Promise(async (resolve, reject)=>{\n            \n            console.log('Data:', data);\n            \n            let {node} = data;\n            let groupStr = '';\n            let groupNode = universe.lodash.find(node.nodes, {type: 'group_by_tag:0.0.1:local:2f9skjf2n1l'});\n            if(groupNode){\n              groupStr = groupNode.data.tag;\n            }\n            \n            groupStr = WINDOW.prompt('Group Tag:', groupStr);\n            if(!groupStr || !groupStr.trim().length){\n              return false;\n            }\n            \n            // Add/Updat\n            \n            // Get ExternalIdentityNode for TalkToSecond \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            \n            if(groupNode){\n              console.log('Updating groupNode');\n              \n              groupNode.data.tag = groupStr.trim();\n            \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // missing Identity! \n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: groupNode\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n            } else {\n              \n              console.log('Saving new groupNode');\n              \n              groupNode = {\n                nodeId: node._id,\n                type: 'group_by_tag:0.0.1:local:2f9skjf2n1l',\n                data: {\n                  tag: groupStr.trim()\n                }\n              }\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // missing Identity! \n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: {skipExistingLearnedNodeId: true}\n                                },\n                                dataNode: groupNode\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        handleChangeTag(e, data){\n          // Add/update existing text info \n          return new Promise(async (resolve, reject)=>{\n            \n            console.log('Data:', data);\n            \n            let {node} = data;\n            let textStr = '';\n            let textNode = universe.lodash.find(node.nodes, {type: 'text_tag:0.0.1:local:239fj23'});\n            if(textNode){\n              textStr = textNode.data.text;\n            }\n            \n            textStr = WINDOW.prompt('Text Tag:', textStr);\n            if(!textStr || !textStr.trim().length){\n              return false;\n            }\n            \n            // Add/Update\n            \n            // Get ExternalIdentityNode for TalkToSecond \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            \n            if(textNode){\n              console.log('Updating textNode');\n              \n              textNode.data.text = textStr.trim();\n            \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // missing Identity! \n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: textNode\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n            } else {\n              \n              console.log('Saving new textNode');\n              \n              textNode = {\n                nodeId: node._id,\n                type: 'text_tag:0.0.1:local:239fj23',\n                data: {\n                  text: textStr.trim()\n                }\n              }\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // missing Identity! \n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: {skipExistingLearnedNodeId: true}\n                                },\n                                dataNode: textNode\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        handleRemoveNode(e, data){\n          // Add/update existing text info \n          return new Promise(async (resolve, reject)=>{\n            \n            console.log('Data:', data);\n            \n            let {node} = data;\n            \n            // Send \"update_node\" command with active=false \n            \n            // Get ExternalIdentityNode for TalkToSecond \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            node.active = false;\n          \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        // missing Identity! \n                        {\n                          matchActionType: 'update_node:0.0.1:local:392821982y3',\n                          dataForAction: {\n                            type: 'node:0.0.1:local:123445',\n                            data: node\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n          \n            console.log('RemovedNode response:', response);\n            \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        handleView(e, data){\n          \n          let {node} = data;\n          this.props.setState({\n            viewingNode: node,\n            ExternalIdentityNode: node\n          })\n          \n          \n        }\n        \n        @autobind\n        handleFileChange(e){\n          const files = e.target.files;\n          let file = files[0];\n          if(file == null){\n            return WINDOW.alert('No file selected.');\n          }\n          this.getSignedRequest(file);\n        }\n        \n        @autobind\n        getSignedRequest(file){\n          \n          return new Promise(async (resolve, reject)=>{\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'request_file_upload:0.0.1:local:00838923flkwne',\n                            dataForAction: {\n                              type: 'request_file_upload:0.0.1:local:00838923flkwne',\n                              data: {\n                                fileName: file.name,\n                                fileType: file.type\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              let fileResponse = response.data.actionResponses[0];\n              \n              // // let componentNode = await universe.runInVM(result[0],{});\n              // this.setState({\n              //   nodes: nodes\n              // })\n              \n              console.log('fileResponse', fileResponse);\n              \n              if(fileResponse.type != 'request_file_upload_response:0.0.1:local:89h91h9f2nsmfd'){\n                console.error('Failed getting signedRequest for uploading file');\n                return;\n              }\n              \n              // Upload to S3\n              await this.uploadFile(file, fileResponse.data.signedRequest, fileResponse.data.url);\n              \n              // console.log('uploadNode:', uploadNode);\n              console.log('Uploaded OK');\n              \n              // Get the \"view\" url \n              let key = fileResponse.data.key;\n              \n              let response2 = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'request_file_get:0.0.1:local:239hfskhf0j9s',\n                            dataForAction: {\n                              type: 'request_file_get:0.0.1:local:239hfskhf0j9s',\n                              data: {\n                                key: key\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              let viewResponse = response2.data.actionResponses[0];\n              let viewUrl = viewResponse.data.url;\n              console.log('View response:', viewResponse, viewResponse.data.url);\n              console.log('Open URL:', viewResponse.data.url);\n              WINDOW.prompt('Url:',viewResponse.data.url);\n              \n              // Save a new Node (with the correct file upload type!) \n              let newPhotoNode = {\n                type: 'photo:0.0.1:local:9832fj293j2f',\n                data: {\n                  url: viewUrl\n                }\n              }\n              \n              let response3 = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // missing Identity! \n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: {skipExistingLearnedNodeId: true}\n                                },\n                                dataNode: newPhotoNode\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('newPhotoNode response:', response3);\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n              \n              \n            } catch(err){\n              console.error('Failed getting signedRequest', err);\n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        uploadFile(file, signedRequest, url){\n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('Uploading File');\n            try {\n                \n              const xhr = new WINDOW.XMLHttpRequest();\n              xhr.open('PUT', signedRequest);\n              xhr.onreadystatechange = () => {\n                if(xhr.readyState === 4){\n                  console.log('File sent!');\n                  if(xhr.status === 200){\n                    // document.getElementById('preview').src = url;\n                    // document.getElementById('avatar-url').value = url;\n                    // WINDOW.alert('Uploaded ok!!!!');\n                    resolve(); //JSON.parse(xhr.responseText));\n                  }\n                  else{\n                    WINDOW.alert('Could NOT upload file.');\n                  }\n                }\n              };\n              xhr.send(file);\n              \n            }catch(err){\n              console.error('Failed file upload:', err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        renderNodes(nodes){\n          \n          nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // What type of Second is this? \n                  // - Friend/Person  \n                  // - Browser \n                  // - Device\n                  // - Unknown\n                  let groupTag = 'Unknown'; \n                  let textTag = 'unknown'; \n                  let groupTagNode = universe.lodash.find(node.nodes,{type: 'group_by_tag:0.0.1:local:2f9skjf2n1l'});\n                  if(groupTagNode){\n                    groupTag = groupTagNode.data.tag;\n                  }\n                  let textTagNode = universe.lodash.find(node.nodes,{type: 'text_tag:0.0.1:local:239fj23'});\n                  if(textTagNode){\n                    textTag = textTagNode.data.text;\n                  }\n                  \n                  let tooltip = node.nodes[0].data.connection;\n                  \n                  return (\n                    <div key={node._id}>\n                    \n                      <ContextMenuTrigger id={\"some_unique_identifier-\" + node._id}>\n                        \n                        <div className=\"tooltip-holder\" style={{cursor:'pointer'}} onClick={e=>this.handleView(e,{node})}>\n                          <div className=\"tooltip-trigger\">\n                            {groupTag}: {textTag}\n                          </div>\n                          {\n                            !tooltip ? '':\n                            <div className=\"tooltip\">\n                              {tooltip}\n                            </div>\n                          }\n                        </div>\n                        \n                      </ContextMenuTrigger>\n                \n                      <ContextMenu id={\"some_unique_identifier-\" + node._id}>\n                        <MenuItem data={{node}} onClick={this.handleChangeTag}>\n                          {node.nodes[0].data.connection}\n                        </MenuItem>\n                        <MenuItem divider />\n                        <MenuItem data={{node}} onClick={this.handleChangeGroup}>\n                          Change Group\n                        </MenuItem>\n                        <MenuItem data={{node}} onClick={this.handleChangeTag}>\n                          Change Tag\n                        </MenuItem>\n                        <MenuItem data={{node}} onClick={this.handleView}>\n                          View\n                        </MenuItem>\n                        <MenuItem divider />\n                        <MenuItem data={{node}} onClick={this.handleRemoveNode}>\n                          Delete\n                        </MenuItem>\n                      </ContextMenu>\n                      \n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\">\n              \n              <div style={{borderBottom: '1px solid #888'}}>\n              \n                <input type=\"file\" id=\"file-input\" onChange={this.handleFileChange} />\n                <p id=\"status\">Please select a file</p>\n                \n              </div>\n              \n              <br />\n              \n              <h3 className=\"title is-4\">\n                Connected:\n                &nbsp;\n                <button className=\"button is-small\" onClick={this.handleAddFriend}>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-plus\"></i>\n                  </span>\n                </button>\n                \n              </h3>\n              <h3 className=\"subtitle is-6\">\n                Remote Seconds\n              </h3>\n              \n              {this.renderNodes(nodes)}\n              \n            </div>\n          )\n        }\n        \n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      ListComponent = universe.ReactRouterDomWithRouter(ListComponent);\n      // console.log('GLOBALSTATE:', universe.ReactGlobalState);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512539258332,"updatedAt":1513153206743,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a27847b9cb84d22ebce6142","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"57f377d7-13fe-4bb7-974b-35328c7a3825","internalId":"ListRemoteConnectedToDataComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let remoteSearchStr;\n          switch(props.resultType){\n            case 'actions':\n              remoteSearchStr = `\n                let actionSearch = {\n                  type: 'action_pointer:0.0.1:local:238972ncr', // should use \"common_type\" ?? \n                }\n                let hasActionPointerChild = miniverse.lodash.find(inputNode.nodes, actionSearch);\n\n                if(!hasActionPointerChild){\n                  return false;\n                }\n                \n                // return action nodes! \n                return inputNode;\n              `\n              break;\n              \n            case 'photos':\n              remoteSearchStr = `\n                if(inputNode.type != 'photo:0.0.1:local:9832fj293j2f'){\n                  return false;\n                }\n                \n                // return action nodes! \n                return inputNode;\n              `\n              break;\n              \n            default:\n              // all\n              remoteSearchStr = `\n                // return action nodes! \n                return inputNode;\n              `\n              break;\n          }\n          \n          this.state = {\n            nodes: [],\n            remoteSearchStr\n          }\n        }\n        \n        componentWillReceiveProps(nextProps){\n          if(nextProps.state.ExternalIdentityNode){\n            // refetch\n            this.fetchDataForRemoteFriend(nextProps);\n          }\n        }\n        \n        @autobind\n        fetchDataForRemoteFriend(props){\n          // fetch data by passing the request through the cloud/server Second \n          \n          props = props || this.props;\n          \n          console.log('fetchDataForRemoteFriend.New Props', props);\n          \n          let {\n            OwnerSecondExternalIdentityNode,\n            ExternalIdentityNode // friend's ExternalIdentityNode on cloud Second\n          } = props.state;\n          \n          if(!OwnerSecondExternalIdentityNode || !ExternalIdentityNode){\n            console.log('Missing OwnerSecondExternalIdentityNode or ExternalIdentityNode', OwnerSecondExternalIdentityNode, ExternalIdentityNode);\n            return false;\n          }\n          \n          console.log('Fetching inside remote:', ExternalIdentityNode);\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              // this is the query sent to the remote! \n              let searchRequestNode = {\n                type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                data: {\n                  matchFunctionNode: {\n                    type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                    data: {\n                      code: `(()=>{\n                        let inputNode = INPUT.data.inputNode;\n                        if(inputNode.nodeId){\n                          return false;\n                        }\n                        \n                        ${this.state.remoteSearchStr}\n                        \n                      })()`\n                    }\n                  },\n                }\n              }\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'search_remote_datasource:0.0.1:local:3249sfj2389fh289',\n                            dataForAction: {\n                              type: 'standard_remote_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                internalId: ExternalIdentityNode._id,\n                                // publicKey: ExternalIdentityNode.data.publicKey,\n                                RequestNode: searchRequestNode\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              console.log('FullExternalResponse', response);\n              \n              let externalResponse = response.data.actionResponses[1];\n              let nodes = externalResponse.data.data;\n              \n              // console.log('NODES in response:', externalResponse);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleClickNode(Node){\n          this.props.setState({\n            ShowDetailNode: Node \n          });\n        }\n        \n        @autobind\n        renderNodes(nodes){\n          nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  try {\n                    switch(node.type){\n                      case 'react_component:0.0.1:local:98912hd89':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn:0.0.1:local:2839fh29':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag:0.0.1:local:239fj23':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability:0.0.1:local:187h78h23':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code:0.0.1:local:32498h32f2':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity:0.0.1:local:8982f982j92':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method:0.0.1:local:382989239hsdfmn':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  return (\n                    <div key={node._id}>\n                      <div onClick={e=>this.handleClickNode(node)} style={{cursor:'pointer'}}>\n                  \n                        <div className=\"hover-item tooltip-holder\">\n                          <div className=\"tooltip-trigger\">\n                            {node.type}\n                          </div>\n                          {\n                            !tooltip ? '':\n                            <div className=\"tooltip\">\n                              {tooltip}\n                            </div>\n                          }\n                        </div>\n                        \n                      </div>\n                      {\n                        !(node.nodes && node.nodes.length) ? '':\n                        <div style={{paddingLeft:'8px'}}>\n                          {this.renderNodes(node.nodes)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          return (\n            <div className=\"\">\n              {\n                this.renderNodes(this.state.nodes)\n              }\n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512539259630,"updatedAt":1513209359383,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a27847d9cb84d22ebce6165","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"7f950e70-f17c-4268-a0f6-1ba848893066","internalId":"MainEditorComponent","note":"user_editor","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            mainTab: '__ALL__',\n            aceHeight: 100,\n            windowHeight: 100,\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.resizeAce();\n          this.handleKeyDown();\n          this.loadSchema(this.props.node.type);\n          this.fetchParentsOfNodesToLearn();\n          \n          universe.EE.on('nodes-modified', this.fetchParentsOfNodesToLearn);\n          \n        }\n        \n        componentWillReceiveProps(nextProps, nextState){\n          \n          // resizing helpers for Ace height\n          if(!nextProps.state.newWindowSize || \n            this.state.windowHeight != nextProps.state.newWindowSize[1]){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          if(nextState.aceHeight == -1){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          // if(nextProps.state.editingNode && this.props.node){\n          //   if(nextProps.state.editingNode._id != this.props.node._id){\n          //     this.setState({\n          //       mainTab: '__ALL__'\n          //     })\n          //   }\n          // }\n          // console.log('nextProps:', nextProps);\n        }\n        \n        componentWillUnmount(){\n          \n          universe.EE.removeListener('nodes-modified', this.fetchParentsOfNodesToLearn);\n          \n        }\n        \n        @autobind\n        resizeAce(){\n          if(!this.parentRef){\n            this.setState({\n              aceHeight: null\n            })\n            return;\n          }\n          // console.log('Resize ace', this.parentRef.offsetHeight);\n          this.setState({\n            aceHeight: this.parentRef.offsetHeight\n          },()=>{\n            if(this.aceRef){\n              this.aceRef.editor.resize();\n            }\n          })\n        }\n      \n        @autobind\n        loadSchema(slug){\n          // from Languages server \n      \n          let data = JSON.parse('{\"operationName\":null,\"variables\":{\"slug\":\"'+slug+'\"},\"query\":\"query ($slug: String) {  languageOne(filter: {slug: $slug}) {    _id    slug    title    schemaCode    schemaObj    createdAt    updatedAt    __typename  }}\"}');\n          data = JSON.stringify(data);\n          universe.$.ajax({\n            url: 'http://lang.second.ngrok.io/graphql',\n            method: 'post',\n            contentType: 'application/json',\n            data: data,\n            success: languageResult=>{\n              // console.log('Languages', languageResult);\n              if(!languageResult.data.languageOne){\n                console.error('Missing Schema for this type!');\n                this.setState({\n                  schema: false\n                })\n                return;\n              }\n              console.log('have Schema:', languageResult);\n              this.setState({\n                schema: languageResult.data.languageOne.schemaObj // jsSchema\n              })\n            },\n            error: err=>{\n              console.error('Failed fetching languages:', err);\n            }\n          })\n      \n        }\n      \n        @autobind\n        async saveDataUpdates(){\n        \n          console.log('Saving updates');\n      \n          let dataBeforeParse = this.props.editState.fields.data.value;\n      \n          let realData;\n    \n          try {\n            realData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            return false;\n          }\n      \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            data: realData, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n        \n        @autobind\n        fetchParentsOfNodesToLearn(){\n          return new Promise(async (resolve, reject)=>{\n            \n            this.setState({\n              fetchingParents: true\n            })\n            \n            let parentNodes = [];\n            try {\n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != \"parent_of_nodes_to_learn:0.0.1:local:2839fh29\"){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.data.environment != \"browser\"){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              parentNodes = response.data.actionResponses[0].data;\n              \n              console.log('parentNodes updated');\n            }catch(err){\n              console.error('Failed updating parentNodes');\n            }\n            \n            this.setState({\n              parentNodes,\n              fetchingParents: false\n            })\n            \n            resolve(parentNodes);\n            \n          });\n        }\n      \n        @autobind\n        async handleUpdateType(){\n        \n          let type = WINDOW.prompt('Type:',this.props.node.type);\n          if(!type){\n            return false;\n          }\n    \n          type = type.trim();\n\n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            type, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        async handleUpdateParent(){\n          \n          console.log('Node:', this.props.node);\n          \n          let nodeId = WINDOW.prompt('Parent Node ID:',this.props.node.nodeId || '');\n          if(!nodeId){\n            return false;\n          }\n    \n          nodeId = nodeId.trim();\n          \n          if(!nodeId.length){\n            nodeId = null;\n          }\n  \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            nodeId,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        handleDuplicate(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = this.props.node;\n      \n            let doParent;\n            if(node.nodeId){\n              doParent = WINDOW.prompt('Keep parent? (y/n)','y');\n              if(!doParent){\n                return false;\n              }\n            }\n      \n            let doChildren;\n            if(node.nodes && node.nodes.length){\n              doChildren = WINDOW.prompt('Keep child nodes? (y/n)','y');\n              if(!doChildren){\n                return false;\n              }\n            }\n      \n            console.log('NODE:', node);\n      \n            // // Send in a Node that will be learned by the AI \n            // {\n            //   type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n            //   data: {\n            //     // what to import! \n            //     _id: \"testingid2\",\n            //     nodeId: null,\n            //     type: \"emoji:0.0.1:local:2f9jsd98fj293fsdf\",\n            //     // expected/allowed schemas for return \n            //     data: {\n            //       emoji: \"joy\"\n            //     }\n            //   }\n            // },\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n      \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: (doParent === 'y') ? node.nodeId:null,\n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            if(doChildren){\n              await saveChildNodes(savedNode.data._id, node.nodes);\n            }\n            \n            console.log('Done duplicating');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n      \n        @autobind\n        handleAddChild(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = this.props.node;\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            this.setState({\n              saving: true\n            });\n      \n            let newNode = {\n              nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n          \n            console.log('Done creating new');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        handleAddChildPaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: this.props.node._id, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n      \n        @autobind\n        handleExportNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(node);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            let nodes = node.nodes || [];\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(nodes);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToLocalStorage(storageKey){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Will overwrite: ' + storageKey);\n            if(!confirm){\n              return false;\n            }\n            \n            // Find the node from the storageKey! \n            // - must be stored in a parent_of_nodes_to_learn tree \n            \n            // parent_of_nodes_to_learn:0.0.1:local:2839fh29\n          \n            let node = universe.lodash.find(this.state.parentNodes,n=>{\n              return n.data.learn == storageKey;\n            });\n            console.log('NODE:', node, this.state.parentNodes);\n            let nodes = JSON.parse(JSON.stringify(node.nodes || []));\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            // let j = JSON.stringify(nodes);\n            // WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            // universe.copy(j);\n            \n            let uiApps = await localforage.getItem('possible-ui-apps');\n            uiApps = uiApps || {};\n            \n            uiApps[storageKey] = nodes;\n            \n                  \n            let updatedApps = await localforage.setItem('possible-ui-apps', uiApps);\n            \n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            node.active = false;\n            let deleted = await this.makeSaveRequest({\n              _id: node._id,\n              active: false\n            }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main' // should keep using for browser development! \n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.saveDataUpdates();\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleChangeMainTab(tabName){\n          \n          // using \"__ALL__\" as the \"main\" holder\n          // - otherwise assume we are editing a field \n          \n          this.setState({\n            mainTab: tabName,\n            aceHeight: 0\n          },()=>{\n            this.resizeAce();\n          })\n        }\n        \n        \n        render(){\n          \n          // add \"fields\" to mainTab for the selected Node \n          // - also should show \"unused\" fields from schema? \n          \n          let node = this.props.node;\n      \n          let { value, parentValue } = this.props.editState.fields.data; // value is always a String!!!! (might not be Parseable tho!) \n    \n          let mainTabs = [\n            ['__ALL__','All']\n          ]\n      \n          let dataBeforeParse = value;\n          let isValidJSON = true;\n          let parsedData;\n          try {\n            parsedData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            isValidJSON = false;\n          }\n      \n      \n          // validates?\n          let data = value;\n          let isValidDataForSchema = false;\n          let schemaValidationErrors = '';\n      \n      \n          if(this.state.schema){\n      \n            if(this.state.schema.type == 'object'){\n      \n              if(typeof data == 'string'){\n                try {\n                  data = JSON.parse(data);\n                }catch(err){\n                  // return false;\n                  data = null;\n                }\n              } else {\n                // leave as-is (assume String/Number) \n              }\n      \n            } else {\n              // use raw value\n              // data = dataBeforeParse;\n            }\n      \n            try {\n              let validate = universe.jsSchema.fromJSON(this.state.schema);\n              let validates = validate(data);\n              // console.log('validates:', validates);\n              if(validates){ \n                isValidDataForSchema = true;\n              } else {\n                schemaValidationErrors = validate.errors(data);\n              }\n              // console.log('schemaValidationErrors',schemaValidationErrors);\n            }catch(err){\n              console.error('jsSchema err:', err);\n            }\n            \n            // tabs\n            if(this.state.schema.type == 'object'\n              && isValidJSON){\n              try {\n                let objTabs = Object.keys(parsedData).map(d=>{return [d,d]});\n                mainTabs = mainTabs.concat(objTabs);\n              }catch(err){\n                \n              }\n            }\n            \n          }\n          \n          let outputVal;\n          if(this.state.mainTab != '__ALL__'){\n            // this.props.editState.fields.data.value ? this.props.editState.fields.data.value.code:''\n            try {\n              // console.log('dATAVAL',this.props.editState.fields.data.value);\n              value = JSON.parse(this.props.editState.fields.data.value)[this.state.mainTab];\n            }catch(err){\n              console.error('failed parsing value for field.', err);\n            }\n          }\n          \n          return (\n            <div className=\"fill-height-or-more\">\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level-NOTANYMORE\">\n                    <div className=\"level-right-NOTANYMORE pull-right\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small is-danger\" onClick={this.handleDelete}>\n                              Delete\n                            </a>\n                          </p>\n                        </div>\n                      </div>\n                    </div>\n                    <div className=\"level-left-NOTANYMORE\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <h3 className=\"title is-4\">\n                          {node.type}\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          {node._id}\n                        </h3>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level\">\n                    <div className=\"level-left\">\n                      <div className=\"level-item\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateType}>\n                              Change Type\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateParent}>\n                              Change Parent\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleDuplicate}>\n                              Duplicate\n                            </a>\n                          </p>\n                          \n                          <div className=\"dropdown is-hoverable is-right\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.addingChild ? ' is-loading':'')}>\n                                <span>Add Child</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleAddChild}>\n                                  Blank\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={e=>this.setState({pastable: !this.state.pastable})}>\n                                  Paste JSON\n                                </a>\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          \n                          <div className=\"dropdown is-hoverable is-right\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.fetchingParents ? ' is-loading':'')}>\n                                <span>Export</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleExportNode}>\n                                  Node to Clipboard\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleExportChildren}>\n                                  Children to ClipBoard\n                                </a>\n                                \n                                {\n                                  (this.state.parentNodes || []).map(parentNode=>{\n                                    return (\n                                      <a key={parentNode._id} className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(parentNode.data.learn)}>\n                                        To LocalStorage: <strong>{parentNode.data ? parentNode.data.learn:'missing'}</strong>\n                                      </a>\n                                    )\n                                  })\n                                }\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          \n                          \n                          {\n                            !this.state.saving ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Saving...\n                              </a>\n                            </p>\n                          }\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button\" onClick={this.handleAddChildPaste}>Save</button>\n                </div>\n              }\n              \n              <div style={{flex:'0 1 auto'}}>\n                <div className=\"tabs\">\n                  <ul>\n                    {\n                      mainTabs.map(tab=>(\n                        <li \n                          key={tab[0]}\n                          className={this.state.mainTab == tab[0] ? \"is-active\":''}\n                          onClick={e=>this.handleChangeMainTab(tab[0])}\n                        ><a>{tab[1]}</a></li>\n                      ))\n                    }\n                  </ul>\n                </div>\n              </div>\n              \n              <div \n                className=\"\" \n                style={{flex:'1 1 auto'}}\n                ref={r=>this.parentRef=r}\n                >\n                <div \n                  style={{height: this.state.aceHeight+'px', position: 'relative'}} \n                  >\n                        \n                  <AceEditor\n                    ref={r=>this.aceRef=r}\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={value}\n                    onChange={v=>{\n                      if(this.state.mainTab == '__ALL__'){\n                        // if(this.state.schema.type == 'object'){\n                        //   this.props.setEditState('data', v)\n                        // } else {\n                        //   // raw\n                          this.props.setEditState('data', v)\n                        // }\n                      } else {\n                        let newObj = {};\n                        newObj[this.state.mainTab] = v;\n                        // console.log('onchangedata:', data, this.props.editState.fields.data);\n                        let newData = Object.assign({},data,newObj)\n                        this.props.setEditState('data', JSON.stringify(newData));\n                      }\n                    }}\n                    name=\"UNIQUE_ID_OF_DIV2\"\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    onLoad={editor=>{\n                      editor.getSession().setUseWrapMode(true);\n                    }}\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      showPrintMargin: false,\n                      enableSnippets: true,\n                      behavioursEnabled: false,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                  \n                </div>\n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      mycomponent = universe.withEditManager(mycomponent,{\n        editProp: 'node',\n        fields: ['type','data'],\n        fieldConvertServerOnceFunc: {\n          data: v=>{\n            return JSON.stringify(v,null,2)\n          }\n        },\n        fieldConvertServerFunc: {\n          // tmpData: v=>{\n          //   if(v){\n      \n          //   }\n          //   return v;\n          // }\n          // data: v=>{\n          //   // jsSchema\n          //   // console.log('NewServerData:', v);\n          //   if(v instanceof String){\n          //     return v;\n          //   }\n          //   return JSON.stringify(v);\n          //   // return JSON.stringify({\n          //   //   data: v // necessary to do this to retain correct types? \n          //   // },null,2)\n          // }\n        },\n        fieldCompareFunc: {\n          // uri: (prev, next)=>{\n          //   console.log('URI compare!:', prev, next);\n          //   return prev === next;\n          // }\n        }\n      });\n\n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512539261900,"updatedAt":1513469116183,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a2c3ccacc1eaf5dc30e0f3a","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"989afd17-9fda-4aa7-8985-89a6d0394613","internalId":"MainDeveloperComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            browserList: null,\n            remoteList: null,\n            mainEditor: null,\n            remoteFriendList: null,\n            remoteFriendDataList: null\n            // browser: null,\n          }\n        }\n        \n        componentDidMount(){\n          \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                browserList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                remoteList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component2');\n            }\n            \n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    //nodeId: same parent Node as this one! \n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'MainEditorComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                mainEditor: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component2');\n            }\n            \n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteConnectedToComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                remoteFriendList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component3');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteConnectedToDataComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                remoteFriendDataList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        \n        render(){\n          \n          const BrowserListComponent = this.state.browserList || ErrorComponent;\n          const RemoteListComponent = this.state.remoteList || ErrorComponent;\n          const RemoteFriendListComponent = this.state.remoteFriendList || ErrorComponent;\n          const RemoteFriendDataListComponent = this.state.remoteFriendDataList || ErrorComponent;\n          \n          const MainEditorComponent = this.state.mainEditor || ErrorComponent;\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <div>\n                  <RemoteListComponent />\n                </div>\n                \n              </div>\n              <div className=\"flex-middle\">\n                \n                {\n                  this.props.state.editingNode ?\n                  <RecreateChildOnPropsChange \n                      node={this.props.state.editingNode}\n                    >\n                    <MainEditorComponent\n                      node={this.props.state.editingNode}\n                    />\n                  </RecreateChildOnPropsChange>\n                  :''\n                }\n                \n              </div>\n              <div className=\"flex-right\">\n                \n                {/*\n                <div>\n                  <RemoteFriendListComponent />\n                </div>\n                */}\n                \n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512848586512,"updatedAt":1513153207978,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a2c3f53cc1eaf5dc30e0ff0","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"1e4d08d3-f995-4b15-9913-df93b3f39d21","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            browserList: null,\n            remoteList: null,\n            mainEditor: null,\n            remoteFriendList: null,\n            remoteFriendDataList: null\n            // browser: null,\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Mounted MainUserComponent');\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            this.props.setState({\n              OwnerSecondExternalIdentityNode: ExternalIdentityNode\n            });\n              \n            \n            let browserList = await this.props.loadComponent({\n              internalId: 'ListComponent'\n            });\n            this.setState({\n              browserList\n            })\n            \n            let remoteList = await this.props.loadComponent({\n              internalId: 'ListRemoteComponent'\n            });\n            this.setState({\n              remoteList\n            })\n            \n            let mainEditor = await this.props.loadComponent({\n              internalId: 'MainEditorComponent'\n            });\n            this.setState({\n              mainEditor\n            })\n            \n            \n            let remoteFriendList = await this.props.loadComponent({\n              internalId: 'ListRemoteConnectedToComponent'\n            });\n            this.setState({\n              remoteFriendList\n            })\n            \n            \n            let remoteFriendDataList = await this.props.loadComponent({\n              internalId: 'ListRemoteConnectedToDataComponent'\n            });\n            this.setState({\n              remoteFriendDataList\n            })\n            \n          \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        \n        render(){\n          \n          const BrowserListComponent = this.state.browserList || ErrorComponent;\n          const RemoteListComponent = this.state.remoteList || ErrorComponent;\n          const RemoteFriendListComponent = this.state.remoteFriendList || ErrorComponent;\n          const RemoteFriendDataListComponent = this.state.remoteFriendDataList || ErrorComponent;\n          \n          const MainEditorComponent = this.state.mainEditor || ErrorComponent;\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                {/* \n                All Friends \n                */}\n                <div>\n                  <RemoteFriendListComponent />\n                </div>\n                \n              </div>\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <div>\n                  <RemoteFriendDataListComponent\n                    resultType=\"actions\"\n                  />\n                </div>\n                \n              </div>\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <div>\n                  <RemoteFriendDataListComponent\n                    resultType=\"photos\"\n                  />\n                </div>\n                \n              </div>\n              <div className=\"flex-middle\">\n                \n                Details\n                \n                <pre><code>{JSON.stringify(this.props.state.ShowDetailNode || this.props.state.ExternalIdentityNode, null, 2)}</code></pre>\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"MainUserComponent"},"active":true,"createdAt":1512849235667,"updatedAt":1513153208319,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a2f781f4656092981e5fd36","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"key":"b312c627-6b2a-49cb-aab1-67193156a40c","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      \n      class DefaultLayout extends React.Component {\n        constructor(props){\n          super(props)\n          this.state = {};\n        }\n        \n        @autobind\n        componentDidMount(){\n          this.fetchPrivateName();\n        }\n        \n        @autobind\n        fetchPrivateName(){\n          \n          return new Promise(async (resolve, reject)=>{\n              \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != 'identity_private:0.0.1:local:3298f2j398233'){\n                                        return false;\n                                      }\n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              let privateNode = nodes[0];\n              console.log('PrivateNode:', privateNode);\n              \n              this.props.setState({\n                privateNode\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          });\n        }\n        \n        @autobind\n        async handleUpdateApp(){\n          \n          // get Code and React ids from local\n          // - fetch new from Teacher \n          \n          \n          // run Capability: Teacher.updateLocal\n          // - learn from Remote \n          // universe.loadAnd\n          \n          \n          this.setState({\n            updatingLocal: true\n          });\n        \n          let response = await universe.loadAndRunCapability('Teacher',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'updateLocalCode',\n              options: {}\n            }\n          });\n          \n          // Iterate over returned \"to Update\" nodes \n          let toUpdate = response.data || [];\n          \n          console.log('Got local toUpdate', toUpdate.length, toUpdate);\n          \n          \n          try {\n            if(!WINDOW.confirm(`Overwrite local with Updates? ${toUpdate.length} changed`)){\n              this.setState({\n                updatingLocal: false\n              });\n              return false;\n            }\n          }catch(err){\n            console.error(err);\n            this.setState({\n              updatingLocal: false\n            });\n            return false;\n          }\n          \n          console.log('Updating (saving locally)');\n          \n          // overwrite...\n          for(let data of toUpdate){\n            let nodeToSave = data.old;\n            nodeToSave.data.code = data.new.data.code;\n            \n            console.log('Updating Local NodeToSave:', nodeToSave);\n            let updatedNode = await universe.updateNode(nodeToSave);\n          }\n          \n          this.setState({\n            updatingLocal: false\n          });\n          \n          WINDOW.alert('done');\n          \n        }\n        \n        @autobind\n        handleUpdateRemote(){\n          // emit Event for remote to update Code and React Components \n          \n        \n          // let ExternalIdentityNodes = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'external_identity:0.0.1:local:8982f982j92',\n          //       data: {\n          //         // commonName: 'main'\n          //       }\n          //     }\n          //   }\n          // });\n          // let ExternalIdentityNode = ExternalIdentityNodes[0];\n          \n          // try {\n            \n          //   let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n          //     type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //     data: {\n          //       action: 'send',\n          //       options: {\n          //         ExternalIdentityNode,\n          //         RequestNode: {\n          //           type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //           data: {\n          //             actions: [\n          //               {\n          //                 matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //                 dataForAction: {\n          //                   type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //                   data: {\n          //                     matchFunctionNode: {\n          //                       // query here!\n          //                       // action_pointer:0.0.1:local:238972ncr\n          //                       type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                       data: {\n          //                         code: `(()=>{\n          //                           // Action \n          //                           // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n          //                           let inputNode = INPUT.data.inputNode;\n                                    \n          //                           if(inputNode.nodeId){\n          //                             return false;\n          //                           }\n                                    \n          //                           if(inputNode.type != 'identity_private:0.0.1:local:3298f2j398233'){\n          //                             return false;\n          //                           }\n          //                           return inputNode;\n                                    \n          //                         })()`\n          //                       }\n          //                     }\n          //                   }\n          //                 }\n          //               }\n          //             ]\n                      \n          //           }\n          //         }\n          //       }\n          //     }\n          //   });\n            \n            \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n            }\n            \n          })\n        }\n      \n        render(){\n          const { component: Component, ...rest } = this.props;\n      \n          return (\n            <Route {...rest} render={matchProps => (\n                \n              <div className=\"full-screen\">\n                <div className=\"flex-header\">\n                  \n                  <nav className=\"navbar is-transparent\">\n                    <div className=\"navbar-brand\">\n                      <Link className=\"navbar-item\" to=\"/\">\n                        <h1 className=\"title is-4\">\n                          Second \n                          {\n                            this.props.state.privateNode && this.props.state.privateNode.data.name ? \n                            <span>: {this.props.state.privateNode.data.name}</span>\n                            :''\n                          }\n                        </h1>\n                      </Link>\n                      <div className=\"navbar-burger burger\" data-target=\"navbarExampleTransparentExample\">\n                        <span></span>\n                        <span></span>\n                        <span></span>\n                      </div>\n                    </div>\n                  \n                    <div id=\"navbarExampleTransparentExample\" className=\"navbar-menu\">\n                      <div className=\"navbar-start\">\n                        <Link className=\"navbar-item\" to=\"/\">\n                          Canvas/Input\n                        </Link>\n                        <div className=\"navbar-item has-dropdown is-hoverable\">\n                          <Link className=\"navbar-link\" to=\"/apps\">\n                            My Apps\n                          </Link>\n                          <div className=\"navbar-dropdown\">\n                            <Link className=\"navbar-item\" to=\"/shop\">\n                              Shop/Sell\n                            </Link>\n                            <Link className=\"navbar-item\" to=\"/events\">\n                              Calendar/Events\n                            </Link>\n                            <hr className=\"navbar-divider\" />\n                            <Link className=\"navbar-item\" to=\"/addapp\">\n                              <span className=\"icon\">\n                                <span className=\"fa fa-plus\"></span>\n                              </span>\n                              Add App\n                            </Link>\n                          </div>\n                        </div>\n                        \n                        <Link className=\"navbar-item\" to=\"/messages\">\n                          Notifications\n                        </Link>\n                        <Link className=\"navbar-item\" to=\"/dev\">\n                          Dev\n                        </Link>\n                      </div>\n                      <div className=\"navbar-end\">\n                      \n                        <div className=\"navbar-item dropdown is-hoverable is-right\">\n                          <div className=\"dropdown-trigger\">\n                                                    \n                            <button className={\"button is-small\" + ((this.state.updatingLocal || this.state.updatingRemote) ? ' is-loading':'')}>\n                              <span>Update Code/React </span>\n                              <span className=\"icon is-small\">\n                                <i className=\"fa fa-angle-down\"></i>\n                              </span>\n                            </button>\n                          </div>\n                          <div className=\"dropdown-menu\">\n                            <div className=\"dropdown-content\">\n                              \n                              <a className=\"dropdown-item\" onClick={this.handleUpdateApp}>\n                                Local App \n                              </a>\n                              <a className=\"dropdown-item\" onClick={this.handleUpdateRemote}>\n                                Remote Second\n                              </a>\n                              \n                            </div>\n                          </div>\n                        </div>\n                          \n                      {/*\n                        <div className=\"navbar-item\">\n                          <button className={\"button is-small \" + (this.state.updatingLocal ? 'is-loading':'')} onClick={this.handleUpdateApp}>\n                            Update App CodeNodes\n                          </button>\n                        </div>\n                        <div className=\"navbar-item\">\n                          <button className={\"button is-small \" + (this.state.updatingRemote ? 'is-loading':'')} onClick={this.handleUpdateRemote}>\n                            Update Remote Code\n                          </button>\n                        </div>\n                      */}\n                      </div>\n                    </div>\n                    \n                  </nav>\n                  \n                </div>\n                \n                <Component {...matchProps} />\n                \n                <div className=\"flex-footer\">\n                  &nbsp;\n                </div>\n                \n                <ReactResizeDetector handleWidth handleHeight onResize={(w,h)=>this.props.setState({newWindowSize:[w,h]})} />\n                \n              </div>\n              \n            )} />\n          )\n        }\n      };\n      \n      DefaultLayout = universe.ReactGlobalState(DefaultLayout);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: DefaultLayout\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"DefaultLayout"},"active":true,"createdAt":1513060383330,"updatedAt":1513389892353,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]},{"_id":"5a3031e08c6d25338bb3f85f","nodeId":"5a2784759cb84d22ebce60ef","type":"react_component:0.0.1:local:98912hd89","data":{"code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            inputText: ''\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Mounted MainCommandsComponent');\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            this.props.setState({\n              OwnerSecondExternalIdentityNode: ExternalIdentityNode\n            });\n            \n            this.fetchPrivateName();\n          \n          });\n          \n        }\n        \n        @autobind\n        fetchPrivateName(){\n          \n          return new Promise(async (resolve, reject)=>{\n              \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != 'identity_private:0.0.1:local:3298f2j398233'){\n                                        return false;\n                                      }\n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              let privateNode = nodes[0];\n              console.log('PrivateNode:', privateNode);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.props.setState({\n                privateNode\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          });\n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        \n        render(){\n          \n          // const MainEditorComponent = this.state.mainEditor || ErrorComponent;\n          \n          // let componentCommands = await this.props.loadComponent({\n          //   internalId: 'ListComponent'\n          // });\n          // this.setState({\n          //   componentCommands\n          // })\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <h3 className=\"title is-5\">\n                  History of Commands\n                </h3>\n                <h3 className=\"subtitle is-6\">\n                  Things you've said\n                </h3>\n                \n              </div>\n              <div className=\"flex-middle\" style={{borderTop:'1px solid #eee', padding: '24px'}}>\n                \n                <div className=\"field\">\n                  <div className=\"control\">\n                    <input \n                      className=\"input\"\n                      type=\"text\" \n                      placeholder=\"Enter text command here\" \n                      value={this.state.inputText}\n                      onChange={e=>this.setState({inputText:e.target.value})}\n                    />\n                  </div>\n                </div>\n                \n                \n                <div className=\"content\">\n                \n                  <ul>\n                  \n                    <li style={{marginLeft:'-30px',listStyle:'none', fontWeight:'bold'}}>\n                      Send a command: \n                    </li>\n                    \n                    <li>\n                      \"who are my friends\" \n                    </li>\n                    \n                    <li>\n                      \"connect to 'friends words here'\" \n                    </li>\n                    \n                    <li>\n                      \"show me photos from friends\" \n                    </li>\n                    \n                    <li>\n                      \"sign me up for an ebay account\" \n                    </li>\n                    \n                    <li>\n                      \"send grandma 50 buckaroos\" \n                    </li>\n                    \n                    <li>\n                      \"call mom\" \n                    </li>\n                    \n                    <li>\n                      \"lemme watch some netflix\" \n                    </li>\n                    \n                    <li>\n                      \"what italian restaurants in san francisco north beach are good?\" \n                    </li>\n                    \n                  </ul>\n                  \n                </div>\n                \n              </div>\n              <div className=\"flex-right\" style={{padding:'4px'}}>\n                \n                <h3 className=\"title is-5\">\n                  Common Inputs\n                </h3>\n                <h3 className=\"subtitle is-6\">\n                  For current sequence\n                </h3>\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"MainCommandsComponent","key":"97babb15-ed8d-42a5-ae26-b197c308189a"},"active":true,"createdAt":1513107936835,"updatedAt":1513389875722,"parent":{"_id":"5a2784759cb84d22ebce60ef","nodeId":"5a27846f9cb84d22ebce60ab","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1512539253182,"updatedAt":null},"nodes":[]}]},{"_id":"5a27847e9cb84d22ebce6176","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539262874,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784809cb84d22ebce6186","nodeId":"5a27847e9cb84d22ebce6176","type":"text_tag:0.0.1:local:239fj23","data":{"text":"run_action_sequence: This is for handling a sequence of actions!"},"active":true,"createdAt":1512539264018,"updatedAt":null,"parent":{"_id":"5a27847e9cb84d22ebce6176","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539262874,"updatedAt":null},"nodes":[]},{"_id":"5a2784819cb84d22ebce6198","nodeId":"5a27847e9cb84d22ebce6176","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"run_action_sequence:0.0.1:local:293fh8239hsdf23f"},"active":true,"createdAt":1512539265080,"updatedAt":null,"parent":{"_id":"5a27847e9cb84d22ebce6176","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539262874,"updatedAt":null},"nodes":[]},{"_id":"5a2784829cb84d22ebce61a9","nodeId":"5a27847e9cb84d22ebce6176","type":"code:0.0.1:local:32498h32f2","data":{"key":"527d0a3f-016d-4215-9f40-94416eb374a0","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // return resolve({\n      //   multiple: 'todo: run multiple actions in sequence!'\n      // });\n      \n      // Should be piping information?? \n      // - just looping for now, expecting to store info in the cache, I guess?? \n      let actionResponses = [];\n      let continueActions = true;\n      for(let INPUT_data_idx in INPUT.data.actions){\n        if(!continueActions){\n          continue;\n        }\n        let INPUT_data = INPUT.data.actions[INPUT_data_idx];\n        \n        let x = 1; // this IS available in the filterNode function below!? \n        \n        let nodes = await universe.searchMemory({\n          filter: {\n            // sqlFilter: {\n            //   type: INPUT.type,\n            // },\n            // function for returning data from the Node, after filtering a bit \n            // - includes both the Node, and Nodes with nodeId (pointers) \n            filterNodes: tmpNodes=>{\n              // this runs isolated, outside of the above context? (not sure) \n              return new Promise((resolve, reject)=>{\n                tmpNodes = tmpNodes.filter(tmpNode=>{\n                  // see if has a ChildNode matching a type \n                  \n                  // // must match action type \n                  // if(tmpNode.type != INPUT.data.matchActionType){\n                  //   return false;\n                  // }\n                  // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  if(tmpNode.type != INPUT_data.matchActionType){\n                    return false;\n                  }\n                  // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                  \n                  // // must have code to run! \n                  // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                  //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                  // });\n                  \n                  // if(!foundChildCode){\n                  //   return false;\n                  // }\n                  \n                  return true;\n                });\n                resolve(tmpNodes);\n              });\n            },\n          }\n        });\n        \n        // return resolve({\n        //   test: 'ok',\n        //   typeMatch: INPUT.data.matchActionType,\n        //   nodes,\n        //   INPUT,\n        //   SELF\n        // });\n        \n        if(nodes && nodes.length){\n          // found Node to run for action! \n          // - assuming only 1 piece of Code possible/available \n          \n          let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n          \n          // run in vm, and pass in the inputSchema Node! \n          // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n          let actionResult;\n          try {\n            actionResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode: INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              timeout: 25 * 1000\n            });\n          }catch(err){\n            // return resolve('FAILED action');\n            actionResponses.push({\n              error: true,\n              msg: 'Failed action',\n              err: (err || '').toString()\n            });\n            continueActions = false;\n            continue;\n          }\n          \n          // validate actionResult!\n          // - todo\n          \n          // adding actionResult to results output\n          // return resolve(actionResult);\n          actionResponses.push(actionResult);\n          \n        } else {\n          // no Node found for handling action :( \n            \n          // return resolve({ \n          //   error: 'No Nodes for action2'\n          // }); // + result);\n          actionResponses.push({ \n            action: INPUT_data,\n            error: 'No Nodes for action2'\n          });\n        }\n        \n      }\n      \n      // resolve all\n      resolve({\n        actionResponses\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512539266254,"updatedAt":1513150332370,"parent":{"_id":"5a27847e9cb84d22ebce6176","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539262874,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784839cb84d22ebce61b9","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539267466,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784849cb84d22ebce61cb","nodeId":"5a2784839cb84d22ebce61b9","type":"text_tag:0.0.1:local:239fj23","data":{"text":"browser_startup"},"active":true,"createdAt":1512539268615,"updatedAt":null,"parent":{"_id":"5a2784839cb84d22ebce61b9","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539267466,"updatedAt":null},"nodes":[]},{"_id":"5a2784859cb84d22ebce61db","nodeId":"5a2784839cb84d22ebce61b9","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"browser_startup:0.0.1:local:8831167ssd"},"active":true,"createdAt":1512539269510,"updatedAt":null,"parent":{"_id":"5a2784839cb84d22ebce61b9","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539267466,"updatedAt":null},"nodes":[]},{"_id":"5a2784869cb84d22ebce61ec","nodeId":"5a2784839cb84d22ebce61b9","type":"code:0.0.1:local:32498h32f2","data":{"key":"d1a7d985-f012-4555-a881-b1cd09431775","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      let result = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'react_component:0.0.1:local:98912hd89',\n            data: {\n              internalId: 'MainComponent'\n            }\n          }\n        }\n      });\n      let componentNode = await universe.runNodeCodeInVM({\n        codeNode: result[0],\n        dataNode: {}\n      });\n      // let componentNode = await universe.runInVM(result[0],{});\n      \n      return resolve(componentNode);\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512539270839,"updatedAt":1513150334474,"parent":{"_id":"5a2784839cb84d22ebce61b9","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539267466,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784879cb84d22ebce61fe","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539271960,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784899cb84d22ebce6210","nodeId":"5a2784879cb84d22ebce61fe","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ping:pong"},"active":true,"createdAt":1512539273053,"updatedAt":null,"parent":{"_id":"5a2784879cb84d22ebce61fe","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539271960,"updatedAt":null},"nodes":[]},{"_id":"5a27848a9cb84d22ebce6220","nodeId":"5a2784879cb84d22ebce61fe","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"ping:0.0.1:local:239fh298fh239h23"},"active":true,"createdAt":1512539274546,"updatedAt":null,"parent":{"_id":"5a2784879cb84d22ebce61fe","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539271960,"updatedAt":null},"nodes":[]},{"_id":"5a27848b9cb84d22ebce6230","nodeId":"5a2784879cb84d22ebce61fe","type":"code:0.0.1:local:32498h32f2","data":{"key":"525d1100-71ab-40fc-893e-02940e7b7211","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      resolve({\n        type: 'pong:0.0.1:local:8992389hfdg',\n        data: 'pong'\n      })\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512539275654,"updatedAt":1513150336521,"parent":{"_id":"5a2784879cb84d22ebce61fe","nodeId":"5a27846f9cb84d22ebce60ab","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512539271960,"updatedAt":null},"nodes":[]}]},{"_id":"5a27848f9cb84d22ebce6264","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512539279375,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784909cb84d22ebce6275","nodeId":"5a27848f9cb84d22ebce6264","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512539280496,"updatedAt":null,"parent":{"_id":"5a27848f9cb84d22ebce6264","nodeId":"5a27846f9cb84d22ebce60ab","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512539279375,"updatedAt":null},"nodes":[]},{"_id":"5a2784919cb84d22ebce6285","nodeId":"5a27848f9cb84d22ebce6264","type":"code:0.0.1:local:32498h32f2","data":{"key":"b8c79f0f-7d4a-4398-a193-1b9477c9550f","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      var key = new universe.rsa({b: 512});\n      key.generateKeyPair(512, 65537); // 2048\n      \n      const keypair = {\n        private: key.exportKey('pkcs8-private-pem'), \n        public: key.exportKey('pkcs8-public-pem'),\n      }\n      \n      let NodeToSave = {\n        type: 'identity_private:0.0.1:local:3298f2j398233',\n        data: keypair\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      \n      resolve({\n        savedNode\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539281795,"updatedAt":1513150338418,"parent":{"_id":"5a27848f9cb84d22ebce6264","nodeId":"5a27846f9cb84d22ebce60ab","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512539279375,"updatedAt":null},"nodes":[]},{"_id":"5a2784929cb84d22ebce6297","nodeId":"5a27848f9cb84d22ebce6264","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: create a new RSA keypair and store locally"},"active":true,"createdAt":1512539282907,"updatedAt":null,"parent":{"_id":"5a27848f9cb84d22ebce6264","nodeId":"5a27846f9cb84d22ebce60ab","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512539279375,"updatedAt":null},"nodes":[]},{"_id":"5a2784949cb84d22ebce62a8","nodeId":"5a27848f9cb84d22ebce6264","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512539284026,"updatedAt":null,"parent":{"_id":"5a27848f9cb84d22ebce6264","nodeId":"5a27846f9cb84d22ebce60ab","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512539279375,"updatedAt":null},"nodes":[]},{"_id":"5a2784959cb84d22ebce62b9","nodeId":"5a27848f9cb84d22ebce6264","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512539285653,"updatedAt":null,"parent":{"_id":"5a27848f9cb84d22ebce6264","nodeId":"5a27846f9cb84d22ebce60ab","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512539279375,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784969cb84d22ebce62ca","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512539286965,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784989cb84d22ebce62da","nodeId":"5a2784969cb84d22ebce62ca","type":"code:0.0.1:local:32498h32f2","data":{"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'new':\n          console.log('Getting new rsa instance');\n          return resolve({\n            type: 's....',\n            data: new universe.rsa(inputOpts)\n          })\n          \n        \n        case 'sign':\n        \n          let stringToSign = inputOpts.stringToSign;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getPrivate',\n              options: {}\n            }\n          });\n          \n          console.log('MY privateIdentity NODE', MyPrivateIdentity);\n          \n          // // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          // let myPublicKey = MyPrivateIdentity.data.public;\n          \n          // let IdentityNode = await getPrivateIdentity();\n          let privateKey = MyPrivateIdentity.data.private;\n\n          let key1 = new universe.rsa(privateKey);\n          let signed = key1.sign(stringToSign);\n\n          return resolve({\n            type: 'string:0.0.1:local:289hf329h93',\n            data: signed.toString('base64')\n          });\n\n          \n        \n        case 'verify':\n          console.log('Verifying', inputOpts);\n          let ChallengeVerifyNode = inputOpts.ChallengeVerifyNode;\n          let key2 = new universe.rsa(ChallengeVerifyNode.data.publicKey);\n\n          let verified = key2.verify(ChallengeVerifyNode.data.challenge, ChallengeVerifyNode.data.solution, undefined, 'base64'); // todo\n\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: verified\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()","note":"Capability: rsa","key":"619427af-8b4b-4c58-975f-9cc95f55d6f6"},"active":true,"createdAt":1512539288080,"updatedAt":1513144766512,"parent":{"_id":"5a2784969cb84d22ebce62ca","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512539286965,"updatedAt":null},"nodes":[]},{"_id":"5a2784999cb84d22ebce62ec","nodeId":"5a2784969cb84d22ebce62ca","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: rsa"},"active":true,"createdAt":1512539289706,"updatedAt":null,"parent":{"_id":"5a2784969cb84d22ebce62ca","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512539286965,"updatedAt":null},"nodes":[]},{"_id":"5a27849a9cb84d22ebce62fc","nodeId":"5a2784969cb84d22ebce62ca","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512539290784,"updatedAt":null,"parent":{"_id":"5a2784969cb84d22ebce62ca","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512539286965,"updatedAt":null},"nodes":[]}]},{"_id":"5a27849b9cb84d22ebce630e","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512539291925,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a27849d9cb84d22ebce631f","nodeId":"5a27849b9cb84d22ebce630e","type":"code:0.0.1:local:32498h32f2","data":{"key":"e7af1532-eb2b-45f6-8673-79199855e487","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'talk':\n        case 'send':\n            \n            // inputOpts\n          \n          let { ExternalIdentityNode, RequestNode } = inputOpts;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let nodeResponse = await universe.loadAndRunCapability('Request',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'make',\n              options: {\n                ExternalIdentityNode,\n                RequestNode\n              }\n            }\n          });\n          \n          return resolve(nodeResponse);\n            \n          // let nodeResponse = await universe. TalkToSecond({\n          //   ExternalIdentityNode: INPUT,\n          //   InputNode: {\n          //     type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //     data: {\n          //       actions: [\n          //         {\n          //           matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //           dataForAction: {\n          //             type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //             data: {\n          //               matchFunctionNode: {\n          //                 // query here!\n          //                 // action_pointer:0.0.1:local:238972ncr\n          //                 type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                 data: {\n          //                   code: codeSearchTemplate\n          //                 }\n          //               },\n          //               // expected/allowed schemas for return \n          //               // outputSchemas: [\n          //               //   'query_result:0.0.1:local:32490usfj23o23f',\n          //               //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //               // ]\n          //             }\n          //           }\n          //         }\n          //       ]\n                \n          //     }\n          //   }\n          // });\n          \n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539293149,"updatedAt":1513150339970,"parent":{"_id":"5a27849b9cb84d22ebce630e","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512539291925,"updatedAt":null},"nodes":[]},{"_id":"5a27849e9cb84d22ebce632f","nodeId":"5a27849b9cb84d22ebce630e","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: TalkToSecond"},"active":true,"createdAt":1512539294681,"updatedAt":null,"parent":{"_id":"5a27849b9cb84d22ebce630e","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512539291925,"updatedAt":null},"nodes":[]},{"_id":"5a2784a09cb84d22ebce6341","nodeId":"5a27849b9cb84d22ebce630e","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512539296015,"updatedAt":null,"parent":{"_id":"5a27849b9cb84d22ebce630e","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512539291925,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784a19cb84d22ebce6352","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512539297269,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784a29cb84d22ebce6364","nodeId":"5a2784a19cb84d22ebce6352","type":"code:0.0.1:local:32498h32f2","data":{"key":"583d064d-7151-44f8-b972-11185d2fc54b","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" token for second1 \n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, authToken } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      // return resolve({\n      //   INPUT\n      // });\n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      \n      // Using my local, private Identity \n      let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'getPrivate',\n          options: {}\n        }\n      });\n      \n      console.log('MY privateIdentity NODE', MyPrivateIdentity);\n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      // ExternalIdentityNode\n      console.log('Making ExternalInitialResponseNodeFull request');\n      let ExternalInitialResponseNodeFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedInitiateIdentifyNode\n          }\n        }\n      });\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      console.log('ExternalInitialResponseNodeFull',ExternalInitialResponseNodeFull);\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      console.log('Verifying challenge I sent', ExternalInitialResponseNode, ExternalIdentityNode);\n      let verified = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'verify',\n          options: {\n            ChallengeVerifyNode:{\n              type: '...',\n              data: {\n                challenge: newChallenge,\n                solution: ExternalInitialResponseNode.data.solution,\n                publicKey: ExternalIdentityNode.data.publicKey\n              }\n            }\n          }\n        }\n      });\n      \n      console.log('Local Verified response:', verified);\n      \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      \n      console.log('Signing remote challenge', ExternalInitialResponseNode);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign: ExternalInitialResponseNode.data.challenge\n          }\n        }\n      });\n      \n      console.log('Local SignedNode response:', SignedNode);\n      \n      \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      let privateConnectMethod = universe.lodash.find(MyPrivateIdentity.nodes, { type: 'private_identity_connect_method:0.0.1:local:9081j29h3' });\n      \n      console.log('AFter Search');\n      \n      if(privateConnectMethod){\n        console.log('Has privateConnectMethod!!!!', privateConnectMethod);\n      } else {\n        console.log('NO privateConnectMethod???');\n      }\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting an encrypted token back for later auth requests \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data, // base64 string \n          connectMethod: privateConnectMethod ? privateConnectMethod.data : undefined\n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      \n      console.log('Making ExternalTokenResponseFull request with WrappedTokenNode', WrappedTokenNode);\n      let ExternalTokenResponseFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedTokenNode\n          }\n        }\n      });\n      \n      console.log('Local ExternalTokenResponseFull response:', ExternalTokenResponseFull);\n      \n      \n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      console.log('AT IDENTIFY STAGE 2');\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode,\n            ok: true\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539298600,"updatedAt":1513150342859,"parent":{"_id":"5a2784a19cb84d22ebce6352","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512539297269,"updatedAt":null},"nodes":[]},{"_id":"5a2784a49cb84d22ebce6374","nodeId":"5a2784a19cb84d22ebce6352","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: IdentifyInitiate"},"active":true,"createdAt":1512539300315,"updatedAt":null,"parent":{"_id":"5a2784a19cb84d22ebce6352","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512539297269,"updatedAt":null},"nodes":[]},{"_id":"5a2784a59cb84d22ebce6385","nodeId":"5a2784a19cb84d22ebce6352","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512539301450,"updatedAt":null,"parent":{"_id":"5a2784a19cb84d22ebce6352","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512539297269,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784a69cb84d22ebce6396","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512539302530,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784a79cb84d22ebce63a7","nodeId":"5a2784a69cb84d22ebce6396","type":"code:0.0.1:local:32498h32f2","data":{"key":"cae006a6-7c84-4de4-b87b-5ef7c675440a","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'createLocal': // should only happen once! \n          console.log('Create a new Local Private Identity');\n              \n          var key = new universe.rsa({b: 512});\n          key.generateKeyPair(512, 65537); // 2048\n          \n          const keypair = {\n            private: key.exportKey('pkcs8-private-pem'), \n            public: key.exportKey('pkcs8-public-pem'),\n          }\n          \n          let NodeToSave = {\n            type: 'identity_private:0.0.1:local:3298f2j398233',\n            data: keypair\n          }\n          \n          // save Node to memory\n          let savedNode = await universe.newNode(NodeToSave);\n          \n          // save the connectMethod as well \n          let childNodeToSave = {\n            nodeId: savedNode._id,\n            type: 'private_identity_connect_method:0.0.1:local:9081j29h3',\n            data: {\n              method: 'http',\n              connection: 'http://localhost:9999'\n            }\n          }\n          \n          let savedChildNode = await universe.newNode(childNodeToSave);\n          // delete savedChildNode.parent; // kill recursion\n          savedNode.nodes = [savedChildNode];\n          \n          return resolve(savedNode);\n          \n        case 'getPrivate':\n        \n          let privateNodes;\n          try{\n            privateNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'identity_private:0.0.1:local:3298f2j398233'\n                }\n              }\n            });\n            if(!privateNodes.length){\n              throw \"No private identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no identity'\n            });\n          }\n\n          let IdentityNode = privateNodes[0];\n          return resolve(IdentityNode);\n          \n        case 'getExternal':\n        \n          let externalNodes;\n          try{\n            externalNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: inputOpts.publicKey\n                  }\n                }\n              }\n            });\n            if(!externalNodes.length){\n              throw \"No external identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no external identity match'\n            });\n          }\n\n          let ExternalIdentityNode = externalNodes[0];\n          return resolve(ExternalIdentityNode);\n          \n          \n        case 'registerOnChain':\n          let remoteCreated = await universe.createAddressForIdentity(inputOpts.words, inputOpts.publicKey, inputOpts.connection)\n          return resolve(remoteCreated);\n          \n          \n        case 'saveExternal':\n          \n          console.log('saveExternal inputOpts', inputOpts);\n          \n          let NodeToSave3 = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n            }\n          }\n          \n          // external_identity:0.0.1:local:8982f982j92\n          // external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // save Node to memory\n          let savedNode3 = await universe.newNode(NodeToSave3);\n          \n          // save the connectMethod as well \n          if(inputOpts.ExternalIdentityNode.nodes){\n            let childNodeToSave3 = {\n              nodeId: savedNode3._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: inputOpts.ExternalIdentityNode.nodes[0].data\n            }\n            \n            let savedChildNode3 = await universe.newNode(childNodeToSave3);\n          }\n          \n          console.log('Saved External, locally');\n          \n          let NewExternalNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getExternal',\n              options: {\n                publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n              }\n            }\n          });\n          \n          console.log('Got NewExternalNode', NewExternalNode);\n          \n          return resolve(NewExternalNode);\n          \n          \n        \n        case 'getAddressForWords':\n          // inputOpts.words = String;\n          // transform to \"string[space]string[space]string[space]\" format \n          let remoteValue = universe.lodash.compact(inputOpts.words.split(' ')).join(' ');\n          // transform to wallet address \n          var hash = universe.bitcoin.crypto.sha256(remoteValue)\n          console.log('hash:', hash);\n          var d = universe.bigi.fromBuffer(hash)\n          console.log('d:', d);\n          var keyPair = new universe.bitcoin.ECPair(d)\n          var address = keyPair.getAddress()\n          console.log('Remote Second Wallet Address', address);\n          return resolve({\n            type:'wallet_address:..',\n            data: address\n          })\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539303957,"updatedAt":1513150346265,"parent":{"_id":"5a2784a69cb84d22ebce6396","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512539302530,"updatedAt":null},"nodes":[]},{"_id":"5a2784a99cb84d22ebce63b7","nodeId":"5a2784a69cb84d22ebce6396","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Identity"},"active":true,"createdAt":1512539305482,"updatedAt":null,"parent":{"_id":"5a2784a69cb84d22ebce6396","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512539302530,"updatedAt":null},"nodes":[]},{"_id":"5a2784aa9cb84d22ebce63c8","nodeId":"5a2784a69cb84d22ebce6396","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512539306853,"updatedAt":null,"parent":{"_id":"5a2784a69cb84d22ebce6396","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512539302530,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784ac9cb84d22ebce63da","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512539308003,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784ad9cb84d22ebce63eb","nodeId":"5a2784ac9cb84d22ebce63da","type":"code:0.0.1:local:32498h32f2","data":{"key":"90bd3427-5301-415d-ac12-c3f9a3c530d0","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'make':\n        \n          console.log('Make Request inputOpts', inputOpts);\n          \n          // Make a request to an external Second \n          // inputOpts: {\n          //   ExternalIdentityNode, // must include connect_method\n          //   RequestNode: InitiateIdentifyNode\n          // }\n          \n          // let ExternalRequestNode = inputOpts.ExternalIdentityNode;\n\n          // ExternalIdentityNode needs to have a NodeChild w/ a connect_method \n          let connectNode = universe.lodash.find(inputOpts.ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n          if(!connectNode){\n            console.error('Missing ConnectNode!');\n            return reject({\n              type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n              data: {\n                str: 'Missing existing ExternalIdentity connect_method child!'\n              }\n            })\n          }\n\n          console.log('Making external request');\n\n          // make web request\n          // - just passing through, assume any Auth is already included? \n          let response = await universe.directToSecond({\n            url: connectNode.data.connection,\n            RequestNode: inputOpts.RequestNode,\n            // method: 'post',\n            // url: connectNode.data.connection, // expecting URL at first! \n            // body: ExternalRequestNode.data.RequestNode,\n            // json: true\n          })\n\n          // ONLY returning a \"second\" response! (no other URL is allowed besides this, for now) \n          return resolve(response.secondResponse);\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539309288,"updatedAt":1513150350304,"parent":{"_id":"5a2784ac9cb84d22ebce63da","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512539308003,"updatedAt":null},"nodes":[]},{"_id":"5a2784ae9cb84d22ebce63fb","nodeId":"5a2784ac9cb84d22ebce63da","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Request"},"active":true,"createdAt":1512539310753,"updatedAt":null,"parent":{"_id":"5a2784ac9cb84d22ebce63da","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512539308003,"updatedAt":null},"nodes":[]},{"_id":"5a2784af9cb84d22ebce640c","nodeId":"5a2784ac9cb84d22ebce63da","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512539311939,"updatedAt":null,"parent":{"_id":"5a2784ac9cb84d22ebce63da","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512539308003,"updatedAt":null},"nodes":[]}]},{"_id":"5a2784b39cb84d22ebce641d","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyActAsInternalUser","version":"1.0.0"},"active":true,"createdAt":1512539315165,"updatedAt":null,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a2784b49cb84d22ebce642f","nodeId":"5a2784b39cb84d22ebce641d","type":"code:0.0.1:local:32498h32f2","data":{"key":"7e8bcd50-27ce-405b-a1ae-367c5d82aee4","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('Starting ActAs Capability');\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       internalUserPassphrase\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, internalUserPassphrase } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      \n      // Upgrades token (gets a new token for ExternalIdentityNode, updates local memory) \n      //- adds InternalUser for remote \n      \n      \n      // Get local ExternalIdentity \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      \n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      \n      // TalkToSecond (runs sequence of auth w/ token, then upgrade) \n      console.log('Token FOR ActAs:', ExternalIdentityNode.data.token, ExternalIdentityNode);\n      let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'send',\n          options: {\n            ExternalIdentityNode,\n            RequestNode: {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                        \n                  {\n                    matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                    dataForAction: {\n                      type: 'string:...',\n                      data: ExternalIdentityNode.data.token\n                    }\n                  },\n                  \n                  {\n                    matchActionType: 'identify_token_upgrade_to_internal_user:0.0.1:local:9281198u',\n                    dataForAction: {\n                      type: 'user_passphrase:0.01...',\n                      data: {\n                        passphrase: internalUserPassphrase\n                      }\n                    }\n                  }\n                ]\n                \n              }\n            }\n          }\n        }\n      });\n      \n      console.log('ActAs Response:', response);\n      \n      // expecting type: upgrade_token_response:0.0.1:local:289fh2389h23sfsvds\n      \n      let tokenResponse = response.data.actionResponses[1];\n      if(tokenResponse.type != 'upgrade_token_response:0.0.1:local:289fh2389h23sfsvds'){\n        console.error('Failed Identity Upgrade to InternalUser');\n        return reject({\n          msg: 'Failed Identity Upgrade to InternalUser', \n          error: true\n        })\n      }\n      let newToken = tokenResponse.data.token;\n      \n      console.log('newToken for ActsAs:', newToken);\n      \n      // Update/save local ExternalIdentityNode with new token \n      ExternalIdentityNode.data.token = newToken;\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      \n      console.log('Updated local ExternalIdentityNode', updatedExternalIdentityNode);\n      \n      return resolve({\n        type: 'identity_upgrade_finish:0.0.1:local:981h3001j3',\n        data: {\n          updatedExternalIdentityNode,\n          newToken\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512539316534,"updatedAt":1513150353107,"parent":{"_id":"5a2784b39cb84d22ebce641d","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyActAsInternalUser","version":"1.0.0"},"active":true,"createdAt":1512539315165,"updatedAt":null},"nodes":[]},{"_id":"5a2784b69cb84d22ebce643f","nodeId":"5a2784b39cb84d22ebce641d","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: IdentifyActAsInternalUser"},"active":true,"createdAt":1512539318177,"updatedAt":null,"parent":{"_id":"5a2784b39cb84d22ebce641d","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyActAsInternalUser","version":"1.0.0"},"active":true,"createdAt":1512539315165,"updatedAt":null},"nodes":[]},{"_id":"5a2784b79cb84d22ebce6452","nodeId":"5a2784b39cb84d22ebce641d","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512539319302,"updatedAt":null,"parent":{"_id":"5a2784b39cb84d22ebce641d","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyActAsInternalUser","version":"1.0.0"},"active":true,"createdAt":1512539315165,"updatedAt":null},"nodes":[]}]},{"_id":"5a30aeab53bec441147604fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Teacher"},"active":true,"createdAt":1513139883417,"updatedAt":1513140662505,"parent":{"_id":"5a27846f9cb84d22ebce60ab","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"environment":"browser","learn":"user_default"},"active":true,"createdAt":1512539247096,"updatedAt":1513577584202},"nodes":[{"_id":"5a30aeab53bec441147604fd","nodeId":"5a30aeab53bec441147604fc","type":"code:0.0.1:local:32498h32f2","data":{"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Teacher\" capability\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'updateLocalCode':\n          console.log('Teacher.updateLocalCode');\n          \n          // Fetch all of my local Code/React nodes \n          // - get the key (unique) for each) \n          // - ask Teacher Second for code matches for code items (and react components) \n          let CodeNodes = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.map(tmpNode=>{\n                    let types = [\n                      'code:0.0.1:local:32498h32f2',\n                      'react_component:0.0.1:local:98912hd89'\n                    ]\n                    if(types.indexOf(tmpNode.type) === -1){\n                      return false;\n                    }\n                    delete tmpNode.parent;\n                    delete tmpNode.nodes;\n                    return tmpNode;\n                  })\n                  resolve(universe.lodash.compact(tmpNodes));\n                });\n              },\n            }\n          });\n          \n          console.log('CodeNodes:', CodeNodes);\n          \n          let codeNodeIds = universe.lodash.compact(CodeNodes.map(n=>{\n            return n.data ? n.data.key:null;\n          }));\n          \n          console.log('codeNodeIds', codeNodeIds);\n        \n        \n          let ExternalIdentityNodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  commonName: 'teacher'\n                }\n              }\n            }\n          });\n          let ExternalIdentityNode = ExternalIdentityNodes[0];\n          \n          try {\n            \n            let teacherResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    // searching for children in a specific folder \n                                    if(!inputNode.parent || \n                                      !inputNode.parent.data || \n                                      inputNode.parent.data.key != 'teaching_sources'){\n                                      return false;\n                                    }\n                                    \n                                    // // if(inputNode.nodeId){\n                                    // //   return false;\n                                    // // }\n                                    \n                                    let types = ${JSON.stringify(codeNodeIds)};\n                                    // let types = ['619427af-8b4b-4c58-975f-9cc95f55d6f6'];\n                                    \n                                    if(types.indexOf(inputNode.data.key) === -1){\n                                      return false;\n                                    }\n                                    delete inputNode.nodes;\n                                    delete inputNode.parent;\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              }\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('Teacher Response', teacherResponse);\n            console.log('TeacherNodes (matching local):', teacherResponse.data.actionResponses[0].data);\n            \n            let TeacherNodes = teacherResponse.data.actionResponses[0].data;\n            \n            let nodesToUpdate = [];\n            \n            // Find which local ones are different \n            for(let node of CodeNodes){\n              // find match in retrieved \n              let tNode = universe.lodash.find(TeacherNodes,tn=>{\n                try {\n                  return tn.data.key == node.data.key;\n                }catch(err){}\n              })\n              if(!tNode){\n                universe.console.info('Missing remote teacherNode:', node.data.key);\n                continue;\n              }\n              let localHash = universe.bitcoin.crypto.sha256(node.data.code).toString();\n              let remoteHash = universe.bitcoin.crypto.sha256(tNode.data.code).toString();\n              if(localHash == remoteHash){\n                universe.console.log('No update needed:', node.data.key);\n                continue;\n              }\n              \n              // should update this one with remote info \n              universe.console.log('--UPDATE FROM--',node, '--TO--', tNode);\n              \n              // // newer updatedAt value? \n              // if(){\n              //   console.error('Local Version is more recent!!!', 'Local:', node, 'Remote:', tNode);\n              //   continue;\n              // }\n              \n              nodesToUpdate.push({\n                old: node,\n                new: tNode\n              });\n              \n            }\n            \n            \n            // var hash = universe.bitcoin.crypto.sha256(words)\n            // Update my local nodes's data.code field \n            \n            \n            return resolve({\n              type: 'array_of_old_and_new_nodes:...',\n              data: nodesToUpdate\n            });\n            \n          }catch(err){\n            console.error('Failed Teacher connection', err);\n            return reject({});\n          }\n          \n        \n          return;\n          \n        default:\n          return reject({});\n          \n      }\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()","key":"db92db6d-bf90-429d-ba03-92ec20c8cff3"},"active":true,"createdAt":1513139883836,"updatedAt":1513221098584,"parent":{"_id":"5a30aeab53bec441147604fc","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Teacher"},"active":true,"createdAt":1513139883417,"updatedAt":1513140662505},"nodes":[]},{"_id":"5a30aeac53bec441147604fe","nodeId":"5a30aeab53bec441147604fc","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Teacher"},"active":true,"createdAt":1513139884113,"updatedAt":1513139904556,"parent":{"_id":"5a30aeab53bec441147604fc","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Teacher"},"active":true,"createdAt":1513139883417,"updatedAt":1513140662505},"nodes":[]},{"_id":"5a30aeac53bec441147604ff","nodeId":"5a30aeab53bec441147604fc","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513139884442,"updatedAt":null,"parent":{"_id":"5a30aeab53bec441147604fc","nodeId":"5a27846f9cb84d22ebce60ab","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Teacher"},"active":true,"createdAt":1513139883417,"updatedAt":1513140662505},"nodes":[]}]}]