[{"_id":"5a1df9f46e69417096b3da89","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1511913972872,"updatedAt":null,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a1dfa036e69417096b3da8a","nodeId":"5a1df9f46e69417096b3da89","type":"code:0.0.1:local:32498h32f2","data":{"key":"807f0fac-5ba8-479c-bc9e-825eac21507a","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: browser_developer\n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - first request (only seeded) \n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      console.log('INPUT start');\n      \n      switch(INPUT.type){\n        \n        case 'incoming_first:0.1.1:local:78882h37':\n        \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          \n          // Load up capabilities! \n          // - by default, only the loadCapabilities endpoint exists! \n          // - capabilities are only loaded ONCE! (NOT TRUE) \n          //   - they could also be monkey-patched in later though...\n          // await universe.loadCapabilities();\n          \n          // identity_private:0.0.1:local:3298f2j398233\n          \n          // let keyNode = await universe.loadAndRunCapability('rsa',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'new',\n          //     options: {b: 512}\n          //   }\n          // });\n          \n          // keyNode.data.generateKeyPair(2048, 65537);\n          \n          // // // Create local IdentityNode \n          // // // - required to talk to any Remote Second \n          // // var key = new universe.rsa({b: 512});\n          // // key.generateKeyPair(2048, 65537);\n          \n          // const keypair = {\n          //   private: keyNode.data.exportKey('pkcs8-private-pem'), \n          //   public: keyNode.data.exportKey('pkcs8-public-pem'),\n          // }\n          \n          // let PrivateIdentityNodeToSave = {\n          //   type: 'identity_private:0.0.1:local:3298f2j398233',\n          //   data: keypair\n          // }\n          \n          // console.log('PrivateIdentityNodeToSave:', PrivateIdentityNodeToSave);\n          \n          // // save Node to memory\n          // let savedIdentityNode = await universe.newNode(PrivateIdentityNodeToSave);\n          \n          \n          \n          // Find remote Second \n          // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // - want a publicKey and a URL returned \n          //   - a whole IdentityNode should be returned? \n          // - return: \n          //   - external_identity:0.0.1:local:8982f982j92\n          //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          let remoteValue;\n          try {\n            remoteValue = WINDOW.prompt('Remote Second','test test');\n          }catch(err){\n            console.error('Not in Tab');\n            remoteValue = 'test test';\n          }\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words: remoteValue\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          // fetch that wallet address, get the first transaction \n          // - first transaction contains IPFS link \n          // - IPFS contains Nodes (without _ids!) \n          let ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('Got ExternalIdentityNode',ExternalIdentityNode);\n          \n          // return resolve({\n          //   ExternalIdentityNode,\n          //   error: true,\n          //   remoteValue,\n          //   address\n          // })\n          \n          \n          let internalUserPassphrase;\n          try {\n            internalUserPassphrase = WINDOW.prompt('Internal User Passphrase','testuserpassphrase');\n          }catch(err){\n            console.error('Not in Tab');\n            internalUserPassphrase = 'testuserpassphrase';\n          }\n          \n          \n          \n          // Authenticate with External Second \n          // - make authenticated requests to a Second (necessary for Learning?) \n          //   - should have ALL requests authenticated \n          // universe.setupExternalSecond();\n          let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'start',\n              options: {\n                externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n              }\n            }\n          });\n          \n          console.log('FINISHED INITIATE in _first!', authExternalIdentityNode);\n          \n          \n          \n          // Could now go Learn something else, if we want! (Doing in browser AND in cloud!) \n          // - effectively \"get the latest version of this stuff\" instead of keeping whatever is local! \n          // - something besides \"browser_developer\" which is what is currently stored \n          // console.log('SKIPPING LOCAL RUN of learning_pointer');\n          \n          \n          // Connect to passed-in data (ExternalIdentityNode) \n          // - run a search_internal_datasource action sequence to acquire the code to run \n          // - run the code on local Second  \n      \n          let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                            \n                      {\n                        matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                        dataForAction: {\n                          type: 'string:...',\n                          data: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" token is here! pre-downloaded!\n                        }\n                      },\n                      \n                      {\n                        matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                        dataForAction: {\n                          type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                          data: {\n                            matchFunctionNode: {\n                              // query here!\n                              // action_pointer:0.0.1:local:238972ncr\n                              type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                              data: {\n                                code: `(()=>{\n                                  // Action \n                                  // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                  \n                                  let inputNode = INPUT.data.inputNode;\n                                  \n                                  if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                    return null;\n                                  }\n                                  \n                                  if(inputNode.data.learn != 'browser_developer'){\n                                    return null;\n                                  }\n                                  \n                                  if(inputNode.nodeId){\n                                    // should be root-level!\n                                    return null;\n                                  }\n                                  \n                                  // strip childnodes\n                                  // delete inputNode.nodes; \n                                  // delete inputNode.parent;\n                                  delete inputNode.data;\n          \n                                  return inputNode;\n                                  \n                                })()`\n                              }\n                            },\n                            // expected/allowed schemas for return \n                            // outputSchemas: [\n                            //   'query_result:0.0.1:local:32490usfj23o23f',\n                            //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                            // ]\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          // Response should include code! \n          let codeResultNode = universe.lodash.find(response.data.actionResponses[1].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          \n          // Run code in local VM \n          // - INPUT.data is ExternalIdentityNode \n          // - connects to external, clears local memory, downloads all new stuff \n          //   - keeps PrivateIdentity! \n          let localResult = await universe.runNodeCodeInVM({\n            codeNode: codeResultNode,\n            dataNode: INPUT.data\n          });\n          \n          \n          // Upgrade connection as an InternalUser (using passphrase) \n          // - this uses the newly-created ExternalIdentityNode user \n          // - also upgrades our local data.token \n          try {\n            \n          // Authenticate with External Second \n          // - make authenticated requests to a Second (necessary for Learning?) \n          //   - should have ALL requests authenticated \n          // universe.setupExternalSecond();\n            \n            // Initiating Identify ...again\n            let authExternalIdentityNode2 = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" \n                }\n              }\n            });\n            \n            console.log('Finished IdentifyInitiate2. Starting IdentifyActAsInternalUser');\n          \n            let actAsNode = await universe.loadAndRunCapability('IdentifyActAsInternalUser',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  internalUserPassphrase\n                }\n              }\n            });\n            console.log('Finished Upgrading local identity with ActAs. actAsNode Response', actAsNode);\n            \n            \n            // Test new user (am I really ActAs?) \\\n            let e2Nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: ExternalIdentityNode.data.publicKey\n                  }\n                }\n              }\n            });\n            let e2node = e2Nodes[0];\n              \n            let e2response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: e2node,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                              \n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: e2node.data.token\n                          }\n                        },\n                        \n                        // {\n                        //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                        //   dataForAction: {\n                        //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                        //     data: {}\n                        //   }\n                        // }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('e2response',e2response);\n            \n          }catch(err){\n            console.error('Failed actAsNode upgrade',err);\n          }\n          \n          \n          \n          return resolve({\n            externalResponse: true,\n            response,\n            codeResultNode,\n            // localResult\n          })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n          \n          \n          break;\n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          // - expecting INPUT.type.data is a node! \n          // - might be actions, or something else \n            \n          console.log('Searching nodes');\n          let nodes = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    // see if has a ChildNode matching a type \n                    let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                      return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                    })\n                    // 'run_action:0.0.1:local:2398y294c23'\n                    if(!foundMatcherChild){\n                      return false;\n                    }\n                    \n                    return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('Searching nodes2');\n          \n          if(nodes && nodes.length){\n            // found Node to run for action! \n  \n            let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n            \n            // run in vm, and pass in the inputSchema Node! \n            // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n            let actionResult;\n            try {\n              actionResult = await universe.runNodeCodeInVM({\n                codeNode,\n                dataNode: INPUT\n              });\n              \n              // ,{\n              //   codeNode, // includes type/schemaName and data \n              //   dataNode: INPUT, // should be another Node that can be used by the action! \n              //   timeout: 15 * 1000\n              // });\n            }catch(err){\n              return resolve('FAILED code from incoming_browser_request');\n            }\n            \n            // validate actionResult!\n            // - todo\n            \n            return resolve(actionResult);\n            // { \n            //   txt: 'Response:', \n            //   nodeTypes: nodes.map(n=>n.type),\n            //   actionResult\n            // }); // + result);\n            \n          } else {\n            // no Node found for handling action :( \n              \n            return resolve({ \n              error: 'No Nodes for action (incoming_browser_request)',\n              INPUT\n            }); // + result);\n          }\n          \n          \n          // switch(INPUT.data.type){\n            \n          //   case 'ping:0.0.1:local:239fh298fh239h23':\n          //     return resolve({\n          //       ping: 'pong'\n          //     });\n            \n          //   case 'browser_startup:0.0.1:local:8831167ssd':\n          //     // setting up initial component \n          //     let result = await universe.searchMemory({\n          //       filter: {\n          //         sqlFilter: {\n          //           type: 'react_component:0.0.1:local:98912hd89',\n          //           data: {\n          //             internalId: 'MainComponent'\n          //           }\n          //         }\n          //       }\n          //     });\n          //     let componentNode = await universe.runInVM(result[0],{});\n              \n          //     return resolve(componentNode);\n            \n          //   default:\n          //     break;\n          // }\n          \n          break;\n          \n          \n        default:\n          break;\n      }\n\n      return resolve({\n        type: 'err:..',\n        data: {\n          msg: 'Missing valid input type'\n        }\n      });\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1511913987779,"updatedAt":1513150314807,"parent":{"_id":"5a1df9f46e69417096b3da89","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1511913972872,"updatedAt":null},"nodes":[]}]},{"_id":"5a1e51f5dd301d7ef14ea6d0","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Storing 'browser_developer' UI here"},"active":true,"createdAt":1511936501170,"updatedAt":1512327830135,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[]},{"_id":"5a1e554fdd301d7ef14ea6f5","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a1c68e684a656521a92cff5","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"key":"582ac9fc-8171-4e5b-9fa9-af8a15fa2bcc","internalId":"MainComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          console.log('MainComponent constructor');\n          super(props);\n          this.state = {\n            browserList: null,\n            remoteList: null,\n            mainEditor: null,\n            remoteFriendList: null,\n            remoteFriendDataList: null\n            // browser: null,\n          }\n        }\n        \n        componentDidMount(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('Loading after componentDidMount on MainComponent');\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                browserList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                remoteList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component2');\n            }\n            \n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    //nodeId: same parent Node as this one! \n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'MainEditorComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                mainEditor: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component2');\n            }\n            \n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteConnectedToComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                remoteFriendList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component3');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteConnectedToDataComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                remoteFriendDataList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        @autobind\n        async handleAddFriend(){\n          let words = WINDOW.prompt('Words for address:','test17 test17');\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          console.log('Address:', address);\n          \n          let Friend_ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('MySecond:', this.props.state.OwnerSecondExternalIdentityNode);\n          console.log('FriendSecond', Friend_ExternalIdentityNode);\n          \n          \n          // Make TalkToSecond request to Identity MySecond with remote \n          let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                      {\n                        matchActionType: 'identify_challenge_initiate:0.0.1:local:8239hf28hf283h',\n                        dataForAction: {\n                          type: 'challenge_init_remote:0.0.1:...',\n                          data: {\n                            ExternalIdentityNode: Friend_ExternalIdentityNode\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('Friend Connection Response:', response);\n          \n        }\n        \n        @autobind\n        handleFileChange(e){\n          const files = e.target.files;\n          let file = files[0];\n          if(file == null){\n            return WINDOW.alert('No file selected.');\n          }\n          this.getSignedRequest(file);\n        }\n        \n        @autobind\n        getSignedRequest(file){\n          \n          return new Promise(async (resolve, reject)=>{\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'request_file_upload:0.0.1:local:00838923flkwne',\n                            dataForAction: {\n                              type: 'request_file_upload:0.0.1:local:00838923flkwne',\n                              data: {\n                                fileName: file.name,\n                                fileType: file.type\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              let fileResponse = response.data.actionResponses[0];\n              \n              // // let componentNode = await universe.runInVM(result[0],{});\n              // this.setState({\n              //   nodes: nodes\n              // })\n              \n              console.log('fileResponse', fileResponse);\n              \n              if(fileResponse.type != 'request_file_upload_response:0.0.1:local:89h91h9f2nsmfd'){\n                console.error('Failed getting signedRequest for uploading file');\n                return;\n              }\n              \n              // Upload to S3\n              await this.uploadFile(file, fileResponse.data.signedRequest, fileResponse.data.url);\n              \n              // console.log('uploadNode:', uploadNode);\n              console.log('Uploaded OK');\n              \n              // Get the \"view\" url \n              let key = fileResponse.data.key;\n              \n              let response2 = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'request_file_get:0.0.1:local:239hfskhf0j9s',\n                            dataForAction: {\n                              type: 'request_file_get:0.0.1:local:239hfskhf0j9s',\n                              data: {\n                                key: key\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              let viewResponse = response2.data.actionResponses[0];\n              \n              console.log('View response:', viewResponse, viewResponse.data.url);\n              \n              try {\n                WINDOW.open(viewResponse.data.url, '_blank');\n              }catch(err){\n                console.error('Unable to open WINDOW.open:', err);\n              }\n              \n              console.log('Opened URL:', viewResponse.data.url);\n              \n              // const xhr = new XMLHttpRequest();\n              // xhr.open('GET', `/sign-s3?file-name=${file.name}&file-type=${file.type}`);\n              // xhr.onreadystatechange = () => {\n              //   if(xhr.readyState === 4){\n              //     if(xhr.status === 200){\n              //       const response = JSON.parse(xhr.responseText);\n              //       uploadFile(file, response.signedRequest, response.url);\n              //     }\n              //     else{\n              //       alert('Could not get signed URL.');\n              //     }\n              //   }\n              // };\n              // xhr.send();\n              \n              \n            } catch(err){\n              console.error('Failed getting signedRequest', err);\n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        uploadFile(file, signedRequest, url){\n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('Uploading File');\n            try {\n                \n              const xhr = new WINDOW.XMLHttpRequest();\n              xhr.open('PUT', signedRequest);\n              xhr.onreadystatechange = () => {\n                if(xhr.readyState === 4){\n                  console.log('File sent!');\n                  if(xhr.status === 200){\n                    // document.getElementById('preview').src = url;\n                    // document.getElementById('avatar-url').value = url;\n                    // WINDOW.alert('Uploaded ok!!!!');\n                    resolve(); //JSON.parse(xhr.responseText));\n                  }\n                  else{\n                    WINDOW.alert('Could NOT upload file.');\n                  }\n                }\n              };\n              xhr.send(file);\n              \n            }catch(err){\n              console.error('Failed file upload:', err);\n            }\n            \n          });\n        }\n        \n        render(){\n          \n          const BrowserListComponent = this.state.browserList || ErrorComponent;\n          const RemoteListComponent = this.state.remoteList || ErrorComponent;\n          const RemoteFriendListComponent = this.state.remoteFriendList || ErrorComponent;\n          const RemoteFriendDataListComponent = this.state.remoteFriendDataList || ErrorComponent;\n          \n          const MainEditorComponent = this.state.mainEditor || ErrorComponent;\n          \n          return (\n            <div className=\"full-screen\">\n              <div className=\"flex-header\">\n                Second - Developer Dashboard \n                \n                <div className=\"pull-right is-pulled-right\">\n                  <button className=\"button is-danger\" onClick={this.handleClearMemory}>\n                    Clear Memory\n                  </button>\n                </div>\n                \n              </div>\n              <div className=\"flex-main\">\n                <div className=\"flex-left\" style={{padding:'4px'}}>\n                  \n                  <div>\n                    <RemoteListComponent />\n                  </div>\n                  \n                </div>\n                <div className=\"flex-middle\">\n                  \n                  {\n                    this.props.state.editingNode ?\n                    <RecreateChildOnPropsChange \n                        node={this.props.state.editingNode}\n                      >\n                      <MainEditorComponent\n                        node={this.props.state.editingNode}\n                      />\n                    </RecreateChildOnPropsChange>\n                    :''\n                  }\n                  \n                </div>\n                <div className=\"flex-right\">\n                  \n                  \n                  <div>\n                  \n                    <input type=\"file\" id=\"file-input\" onChange={this.handleFileChange} />\n                    <p id=\"status\">Please select a file</p>\n                    \n                  </div>\n                  \n                  \n                </div>\n              </div>\n              <div className=\"flex-footer\">\n                &nbsp;\n              </div>\n              \n              <ReactResizeDetector handleWidth handleHeight onResize={(w,h)=>this.props.setState({newWindowSize:[w,h]})} />\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1511811302756,"updatedAt":1513153201834,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]},{"_id":"5a1e6933dd301d7ef14eaa04","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"key":"e112ac57-d342-4d1e-ab6e-fe36f1ff32b7","internalId":"ListComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n                \n              let nodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    nodeId: null\n                  }\n                }\n              });\n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        render(){\n          return (\n            <div className=\"\">\n              {\n                this.state.nodes.map(node=>{\n                  return (\n                    <div key={node._id}>\n                      {node.type}\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1511942451565,"updatedAt":1513153202313,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]},{"_id":"5a1f0b8edd301d7ef14eaccc","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"key":"0bc77d42-ffa9-4528-8948-d96acff91a2b","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: [],\n            text: '',\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchRemoteNodes();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchRemoteNodes);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchRemoteNodes);\n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              this.props.setState({\n                OwnerSecondExternalIdentityNode: ExternalIdentityNode\n              });\n      \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n      \n        @autobind\n        handleNewNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        handleClickNode(node){\n          this.props.setState({\n            editingNode: node\n          })\n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleNewId(){\n          let uuid = universe.uuidv4();\n          universe.copy(uuid);\n          console.log('Copied to clipboard');\n        }\n        \n        @autobind\n        renderNodes(nodes, parentInFilter){\n          \n          let filter = this.state.text;\n          \n          nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          // console.log('Nodes',nodes);\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                \n                  const nodeMatchFunc = (node) => {\n                    let nodeMatch;\n                    if(node.type && node.type.includes(filter)){\n                      nodeMatch = true;\n                    }\n                    if(node.data && JSON.stringify(node.data).includes(filter)){\n                      nodeMatch = true;\n                    }\n                    // type (t:)\n                    if(filter.includes('t:') && node.type){\n                      let tmpFilter = filter.split('t:')[1];\n                      if(node.type && node.type.includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    // data (d:) \n                    if(filter.includes('d:')){\n                      let tmpFilter = filter.split('d:')[1];\n                      if(node.data && JSON.stringify(node.data).includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    \n                    return nodeMatch;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = filter.length ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  try {\n                    switch(node.type){\n                      case 'react_component:0.0.1:local:98912hd89':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn:0.0.1:local:2839fh29':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag:0.0.1:local:239fj23':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability:0.0.1:local:187h78h23':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code:0.0.1:local:32498h32f2':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity:0.0.1:local:8982f982j92':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method:0.0.1:local:382989239hsdfmn':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  return (\n                    <div key={node._id}>\n                      <div onClick={e=>this.handleClickNode(node)} style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                    \n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              {\n                                (this.props.state.editingNode && this.props.state.editingNode._id == node._id) ?\n                                  <strong>\n                                    {node.type}\n                                  </strong>\n                                  :\n                                  node.type\n                              }\n                            </div>\n                            {\n                              !tooltip ? '':\n                              <div className=\"tooltip\">\n                                {tooltip}\n                              </div>\n                            }\n                          </div>\n                          \n                      </div>\n                      {\n                        !(node.nodes && node.nodes.length) ? '':\n                        <div style={{paddingLeft:'8px'}}>\n                          {this.renderNodes(node.nodes, parentInFilter || nodeMatch)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\">\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button\" onClick={this.handleInsertNodePaste}>Save</button>\n                </div>\n              }\n              \n              <strong>\n                My Cloud Second Memory\n                &nbsp;\n                <button className=\"button is-small\" onClick={this.handleNewNode}>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-plus\"></i>\n                  </span>\n                </button>\n                &nbsp;\n                \n                <div className=\"dropdown is-hoverable is-right\">\n                  <div className=\"dropdown-trigger\">\n                    <button className=\"button is-small\">\n                      <span className=\"icon is-small\">\n                        <i className=\"fa fa-angle-down\"></i>\n                      </span>\n                    </button>\n                  </div>\n                  <div className=\"dropdown-menu\">\n                    <div className=\"dropdown-content\">\n                    \n                      <a className=\"dropdown-item\" onClick={this.handleNewId}>\n                        Copy UUID to Clipboard\n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={this.handleEncryptString}>\n                        Encrypt String\n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={e=>this.setState({pastable:true})}>\n                        Insert Node By Paste\n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={this.handleAddMany}>\n                        Insert Many for Test\n                      </a>\n                      \n                    </div>\n                  </div>\n                </div>\n                \n              </strong>\n              \n              \n              <div>\n                <input className=\"input\" value={this.state.text} onChange={e=>this.setState({text:e.target.value})} placeholder=\"Filter on type/data\" />\n              </div>\n              \n              {this.renderNodes(nodes)}\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"ListRemoteComponent"},"active":true,"createdAt":1511984014323,"updatedAt":1513209331570,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]},{"_id":"5a1f0ba7dd301d7ef14eacd4","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"key":"26763984-229e-4229-a72a-fc41899a8c1c","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // Imports\n      const { ContextMenu, MenuItem, ContextMenuTrigger } = universe.ReactContextMenu;\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n                  \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != 'external_identity:0.0.1:local:8982f982j92'){\n                                        return false\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleClick(ExternalIdentityNode){\n          console.log('Clicked ExternalIdentityNode');\n          this.props.setState({\n            ExternalIdentityNode \n          });\n        }\n        \n        @autobind\n        handleContextClick(e, data){\n          // console.log('Clicked ExternalIdentityNode');\n          // this.props.setState({\n          //   ExternalIdentityNode \n          // });\n          console.log('Clicked:', data);\n        }\n        \n        render(){\n          return (\n            <div className=\"\">\n              \n              {\n                this.state.nodes.map(node=>{\n                  return (\n                    <div key={node._id}>\n                    \n                      <ContextMenuTrigger id={\"some_unique_identifier-\" + node._id}>\n                        <div className=\"well\" onClick={e=>this.handleClick(node)}>\n                          {node.type}\n                        </div>\n                      </ContextMenuTrigger>\n                \n                      <ContextMenu id={\"some_unique_identifier-\" + node._id}>\n                        <MenuItem data={{test:'test1'}} onClick={this.handleContextClick}>\n                          ContextMenu Item 1\n                        </MenuItem>\n                        <MenuItem data={{test:'test1'}} onClick={this.handleContextClick}>\n                          ContextMenu Item 2\n                        </MenuItem>\n                        <MenuItem divider />\n                        <MenuItem data={{test:'test1'}} onClick={this.handleContextClick}>\n                   \t      ContextMenu Item 3\n                        </MenuItem>\n                      </ContextMenu>\n                      \n                    </div>\n                  )\n                })\n              }\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      // console.log('GLOBALSTATE:', universe.ReactGlobalState);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"ListRemoteConnectedToComponent"},"active":true,"createdAt":1511984039135,"updatedAt":1513153203133,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]},{"_id":"5a1f1946dd301d7ef14eae39","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"key":"5a41bf28-d345-45d6-97d8-8d8f8987cdcf","internalId":"ListRemoteConnectedToDataComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n          }\n        }\n        \n        componentWillReceiveProps(nextProps){\n          if(nextProps.state.ExternalIdentityNode){\n            // refetch\n            this.fetchDataForRemoteFriend(nextProps);\n          }\n        }\n        \n        @autobind\n        fetchDataForRemoteFriend(props){\n          // fetch data by passing the request through the cloud/server Second \n          \n          props = props || this.props;\n          \n          console.log('fetchDataForRemoteFriend.New Props', props);\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              let {\n                OwnerSecondExternalIdentityNode,\n                ExternalIdentityNode // friend's ExternalIdentityNode on cloud Second\n              } = props.state;\n                  \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_remote_datasource:0.0.1:local:3249sfj2389fh289',\n                            dataForAction: {\n                              type: 'xyzcystandard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                internalId: ExternalIdentityNode.data.internalId,\n                                publicKey: ExternalIdentityNode.data.publicKey,\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes\n              })\n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleClick(ExternalIdentityNode){\n          // this.props.setState({\n          //   ExternalIdentityNode \n          // });\n        }\n        \n        render(){\n          return (\n            <div className=\"\">\n              {\n                JSON.stringify(this.state)\n              }\n              {/*\n                this.state.nodes.map(node=>{\n                  return (\n                    <div key={node._id} onClick={e=>this.handleClick(node)}>\n                      {node.type}\n                    </div>\n                  )\n                })\n              */}\n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1511987526119,"updatedAt":1513153203545,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]},{"_id":"5a2061ccdd301d7ef14eb324","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"key":"5155a25e-798f-4b58-a356-0fb142a4462b","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            browserList: null,\n            remoteList: null,\n            remoteFriendList: null,\n            remoteFriendDataList: null\n            // browser: null,\n          }\n        }\n        \n        componentDidMount(){\n          \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runNodeCodeInVM({\n                codeNode: result[0],\n                dataNode: {}\n              });\n              this.setState({\n                browserList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runNodeCodeInVM({\n                codeNode: result[0],\n                dataNode: {}\n              });\n              this.setState({\n                remoteList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component2');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteConnectedToComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runNodeCodeInVM({\n                codeNode: result[0],\n                dataNode: {}\n              });\n              this.setState({\n                remoteFriendList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component3');\n            }\n            \n            try {\n                \n              let result = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'react_component:0.0.1:local:98912hd89',\n                    data: {\n                      internalId: 'ListRemoteConnectedToDataComponent'\n                    }\n                  }\n                }\n              });\n              let componentNode = await universe.runNodeCodeInVM({\n                codeNode: result[0],\n                dataNode: {}\n              });\n              this.setState({\n                remoteFriendDataList: componentNode.data\n              })\n            } catch(err){\n              console.error('Failed getting new component4');\n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        render(){\n          \n          const BrowserListComponent = this.state.browserList || ErrorComponent;\n          const RemoteListComponent = this.state.remoteList || ErrorComponent;\n          const RemoteFriendListComponent = this.state.remoteFriendList || ErrorComponent;\n          const RemoteFriendDataListComponent = this.state.remoteFriendDataList || ErrorComponent;\n          \n          return (\n            <div className=\"full-screen\">\n              <div className=\"flex-header\">\n                Second - Developer Dashboard \n                \n                <div className=\"pull-right is-pulled-right\">\n                  <button className=\"button is-danger\" onClick={this.handleClearMemory}>\n                    Clear Memory\n                  </button>\n                </div>\n                \n              </div>\n              <div className=\"flex-main\">\n                <div className=\"flex-left\">\n                  \n                  <strong>\n                    My Cloud Second Memory\n                  </strong>\n                  \n                  <div>\n                    <RemoteListComponent />\n                  </div>\n                  \n                </div>\n                <div className=\"flex-left\">\n                  \n                  <strong>\n                    My Cloud Second Memory\n                  </strong>\n                  \n                  <div>\n                    <RemoteListComponent />\n                  </div>\n                  \n                </div>\n                <div className=\"flex-middle\">\n                   \n                  <AceEditor\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={\"what the fuck\"}\n                    onChange2={v=>this.props.setEditState('data',v)}\n                    name=\"UNIQUE_ID_OF_DIV2\"\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      enableSnippets: true,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                  \n                </div>\n                <div className=\"flex-right\">\n                  \n                  <strong>\n                    Data from Cloud Friend/Group/etc.\n                  </strong>\n                  \n                  \n                </div>\n              </div>\n              <div className=\"flex-footer\">\n                &nbsp;\n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()","internalId":"MainComponent_old"},"active":true,"createdAt":1512071628596,"updatedAt":1513153203982,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]},{"_id":"5a206dcedd301d7ef14eb4af","nodeId":"5a1e554fdd301d7ef14ea6f5","type":"react_component:0.0.1:local:98912hd89","data":{"internalId":"MainEditorComponent","code":"(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            mainTab: '__ALL__',\n            aceHeight: 100,\n            windowHeight: 100,\n            fetchingParents: false\n          }\n        }\n        \n        componentDidMount(){\n          this.resizeAce();\n          this.handleKeyDown();\n          this.loadSchema(this.props.node.type);\n          this.fetchParentsOfNodesToLearn();\n          \n          universe.EE.on('nodes-modified', this.fetchParentsOfNodesToLearn);\n        \n        }\n        \n        componentWillUnmount(){\n          console.log('Unmounting');\n          \n          universe.EE.removeListener('nodes-modified', this.fetchParentsOfNodesToLearn);\n        \n        }\n        \n        componentWillReceiveProps(nextProps, nextState){\n          \n          // resizing helpers for Ace height\n          if(!nextProps.state.newWindowSize || \n            this.state.windowHeight != nextProps.state.newWindowSize[1]){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          if(nextState.aceHeight == -1){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          \n          // this.fetchParentsOfNodesToLearn();\n          \n          // if(nextProps.state.editingNode && this.props.node){\n          //   if(nextProps.state.editingNode._id != this.props.node._id){\n          //     this.setState({\n          //       mainTab: '__ALL__'\n          //     })\n          //   }\n          // }\n          // console.log('nextProps:', nextProps);\n        }\n        \n        @autobind\n        fetchParentsOfNodesToLearn(){\n          return new Promise(async (resolve, reject)=>{\n            \n            this.setState({\n              fetchingParents: true\n            })\n            \n            let parentNodes = [];\n            try {\n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != \"parent_of_nodes_to_learn:0.0.1:local:2839fh29\"){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              parentNodes = response.data.actionResponses[0].data;\n              \n              console.log('parentNodes updated');\n            }catch(err){\n              console.error('Failed updating parentNodes');\n            }\n            \n            this.setState({\n              parentNodes,\n              fetchingParents: false\n            })\n            \n            resolve(parentNodes);\n            \n          });\n        }\n        \n        @autobind\n        handleUpdateCodeNodesWithId(){\n          return new Promise(async (resolve, reject)=>{\n            \n            alert('old method for creating a bunch of uuids');\n            return false;\n            \n            let parentNodes = [];\n            try {\n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      // if(inputNode.nodeId){\n                                      //   return false;\n                                      // }\n                                      \n                                      // if(inputNode.type != \"code:0.0.1:local:32498h32f2\"){\n                                      //   return false;\n                                      // }\n                                      if(inputNode.type != \"react_component:0.0.1:local:98912hd89\"){\n                                        return false;\n                                      }\n                                      \n                                      \n                                      delete inputNode.parent;\n                                      delete inputNode.nodes;\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              codeNodes = response.data.actionResponses[0].data;\n              \n              console.log('codeNodes', JSON.parse(JSON.stringify(codeNodes)));\n              \n              // iterate over codeNodes \n              // - create new UUID for unique ones \n              for(let cn of codeNodes){\n                \n                if(!cn.data.key){\n                    \n                  // get sha for code \n                  let sha = universe.SHA256(cn.data.code).toString();\n                  // console.log('sha1:', sha);\n                  \n                  // other codeNode with that sha that matches (and has a key already)?\n                  let found = universe.lodash.find(codeNodes, cn2=>{\n                    let sha2 = universe.SHA256(cn2.data.code).toString();\n                    if(sha == sha2){\n                      // match \n                      if(cn2.data.key){\n                        return true;\n                      }\n                    }\n                  });\n                  \n                  let newKey;\n                  if(found){\n                    newKey = found.data.key;\n                    console.log('match with key existing!', found.data.key);\n                  } else {\n                    newKey = universe.uuidv4();\n                  }\n                  \n                  cn.data.key = newKey;\n                  \n                  // save updated node! \n                  await this.makeSaveRequest(cn, true);\n                        \n                  // \n                  \n                }\n                \n              }\n              \n              console.log('Updated codeNodes:', codeNodes);\n              \n            }catch(err){\n              console.error('Failed updating codeNodes',err);\n            }\n            \n            resolve();\n            \n          });\n        }\n        \n        @autobind\n        resizeAce(){\n          if(!this.parentRef){\n            this.setState({\n              aceHeight: null\n            })\n            return;\n          }\n          // console.log('Resize ace', this.parentRef.offsetHeight);\n          this.setState({\n            aceHeight: this.parentRef.offsetHeight\n          },()=>{\n            if(this.aceRef){\n              this.aceRef.editor.resize();\n            }\n          })\n        }\n      \n        @autobind\n        loadSchema(slug){\n          // from Languages server \n      \n          let data = JSON.parse('{\"operationName\":null,\"variables\":{\"slug\":\"'+slug+'\"},\"query\":\"query ($slug: String) {  languageOne(filter: {slug: $slug}) {    _id    slug    title    schemaCode    schemaObj    createdAt    updatedAt    __typename  }}\"}');\n          data = JSON.stringify(data);\n          universe.$.ajax({\n            url: 'http://localhost:7011/graphql',\n            method: 'post',\n            contentType: 'application/json',\n            data: data,\n            success: languageResult=>{\n              // console.log('Languages', languageResult);\n              if(!languageResult.data.languageOne){\n                console.error('Missing Schema for this type!');\n                this.setState({\n                  schema: false\n                })\n                return;\n              }\n              console.log('have Schema:', languageResult);\n              this.setState({\n                schema: languageResult.data.languageOne.schemaObj // jsSchema\n              })\n            },\n            error: err=>{\n              console.error('Failed fetching languages:', err);\n            }\n          })\n      \n        }\n      \n        @autobind\n        async saveDataUpdates(){\n        \n          console.log('Saving updates');\n      \n          let dataBeforeParse = this.props.editState.fields.data.value;\n      \n          let realData;\n    \n          try {\n            realData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            return false;\n          }\n      \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            data: realData, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        async handleUpdateType(){\n        \n          let type = WINDOW.prompt('Type:',this.props.node.type);\n          if(!type){\n            return false;\n          }\n    \n          type = type.trim();\n\n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            type, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        async handleUpdateParent(){\n          \n          console.log('Node:', this.props.node);\n          \n          let nodeId = WINDOW.prompt('Parent Node ID:',this.props.node.nodeId || '');\n          if(!nodeId){\n            return false;\n          }\n    \n          nodeId = nodeId.trim();\n          \n          if(!nodeId.length){\n            nodeId = null;\n          }\n  \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            nodeId,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        handleDuplicate(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = this.props.node;\n      \n            let doParent;\n            if(node.nodeId){\n              doParent = WINDOW.prompt('Keep parent? (y/n)','y');\n              if(!doParent){\n                return false;\n              }\n            }\n      \n            let doChildren;\n            if(node.nodes && node.nodes.length){\n              doChildren = WINDOW.prompt('Keep child nodes? (y/n)','y');\n              if(!doChildren){\n                return false;\n              }\n            }\n      \n            console.log('NODE:', node);\n      \n            // // Send in a Node that will be learned by the AI \n            // {\n            //   type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n            //   data: {\n            //     // what to import! \n            //     _id: \"testingid2\",\n            //     nodeId: null,\n            //     type: \"emoji:0.0.1:local:2f9jsd98fj293fsdf\",\n            //     // expected/allowed schemas for return \n            //     data: {\n            //       emoji: \"joy\"\n            //     }\n            //   }\n            // },\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n      \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: (doParent === 'y') ? node.nodeId:null,\n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            if(doChildren){\n              await saveChildNodes(savedNode.data._id, node.nodes);\n            }\n            \n            console.log('Done duplicating');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n      \n        @autobind\n        handleAddChild(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = this.props.node;\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            this.setState({\n              saving: true\n            });\n      \n            let newNode = {\n              nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node', savedNode);\n          \n            console.log('Done creating new');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        handleSaveToTeacher(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // Fetches matching Node from Teacher (by Key, in the correct Folder teaching_source) \n            // Runs update_node with updated data.code (should also update InternalId?) from local \n            \n            console.log('handelSaveToTeacher');\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(node);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            let nodes = node.nodes || [];\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(nodes);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToLocalStorage(storageKey){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Will overwrite: ' + storageKey);\n            if(!confirm){\n              return false;\n            }\n            \n            // Find the node from the storageKey! \n            // - must be stored in a parent_of_nodes_to_learn tree \n            \n            // parent_of_nodes_to_learn:0.0.1:local:2839fh29\n          \n            let node = universe.lodash.find(this.state.parentNodes,n=>{\n              return n.data.learn == storageKey;\n            });\n            console.log('NODE:', node, this.state.parentNodes);\n            let nodes = JSON.parse(JSON.stringify(node.nodes || []));\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            // let j = JSON.stringify(nodes);\n            // WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            // universe.copy(j);\n            \n            let uiApps = await localforage.getItem('possible-ui-apps');\n            uiApps = uiApps || {};\n            \n            uiApps[storageKey] = nodes;\n            \n                  \n            let updatedApps = await localforage.setItem('possible-ui-apps', uiApps);\n            \n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            node.active = false;\n            let deleted = await this.makeSaveRequest({\n              _id: node._id,\n              active: false\n            }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.saveDataUpdates();\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleChangeMainTab(tabName){\n          \n          // using \"__ALL__\" as the \"main\" holder\n          // - otherwise assume we are editing a field \n          \n          this.setState({\n            mainTab: tabName,\n            aceHeight: 0\n          },()=>{\n            this.resizeAce();\n          })\n        }\n        \n        \n        render(){\n          \n          // add \"fields\" to mainTab for the selected Node \n          // - also should show \"unused\" fields from schema? \n          \n          let node = this.props.node;\n          \n          if(!this.props.editState.fields || !this.props.editState.fields.data){\n            return render(\n              <div>\n                Failed Rendering EditManager\n              </div>\n            );\n          }\n          \n          let { value, parentValue } = this.props.editState.fields.data; // value is always a String!!!! (might not be Parseable tho!) \n    \n          let mainTabs = [\n            ['__ALL__','All']\n          ]\n      \n          let dataBeforeParse = value;\n          let isValidJSON = true;\n          let parsedData;\n          try {\n            parsedData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            isValidJSON = false;\n          }\n      \n      \n          // validates?\n          let data = value;\n          let isValidDataForSchema = false;\n          let schemaValidationErrors = '';\n      \n      \n          if(this.state.schema){\n      \n            if(this.state.schema.type == 'object'){\n      \n              if(typeof data == 'string'){\n                try {\n                  data = JSON.parse(data);\n                }catch(err){\n                  // return false;\n                  data = null;\n                }\n              } else {\n                // leave as-is (assume String/Number) \n              }\n      \n            } else {\n              // use raw value\n              // data = dataBeforeParse;\n            }\n      \n            try {\n              let validate = universe.jsSchema.fromJSON(this.state.schema);\n              let validates = validate(data);\n              // console.log('validates:', validates);\n              if(validates){ \n                isValidDataForSchema = true;\n              } else {\n                schemaValidationErrors = validate.errors(data);\n              }\n              // console.log('schemaValidationErrors',schemaValidationErrors);\n            }catch(err){\n              console.error('jsSchema err:', err);\n            }\n            \n            // tabs\n            if(this.state.schema.type == 'object'\n              && isValidJSON){\n              try {\n                let objTabs = Object.keys(parsedData).map(d=>{return [d,d]});\n                mainTabs = mainTabs.concat(objTabs);\n              }catch(err){\n                \n              }\n            }\n            \n          }\n          \n          let outputVal;\n          if(this.state.mainTab != '__ALL__'){\n            // this.props.editState.fields.data.value ? this.props.editState.fields.data.value.code:''\n            try {\n              // console.log('dATAVAL',this.props.editState.fields.data.value);\n              value = JSON.parse(this.props.editState.fields.data.value)[this.state.mainTab];\n            }catch(err){\n              console.error('failed parsing value for field.', err);\n            }\n          }\n          \n          return (\n            <div className=\"fill-height-or-more\">\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level-NOTANYMORE\">\n                    <div className=\"level-right-NOTANYMORE pull-right\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small is-danger\" onClick={this.handleDelete}>\n                              Delete\n                            </a>\n                          </p>\n                        </div>\n                      </div>\n                    </div>\n                    <div className=\"level-left-NOTANYMORE\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <h3 className=\"title is-4\">\n                          {node.type}\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          {node._id}\n                        </h3>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level\">\n                    <div className=\"level-left\">\n                      <div className=\"level-item\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateType}>\n                              Change Type\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateParent}>\n                              Change Parent\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleDuplicate}>\n                              Duplicate\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleAddChild}>\n                              Add Child\n                            </a>\n                          </p>\n                          \n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleSaveToTeacher}>\n                              Save to Teacher\n                            </a>\n                          </p>\n                          {/*\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateCodeNodesWithId}>\n                              CODE UPDATE\n                            </a>\n                          </p>\n                          */}\n                          \n                          \n                                    \n                          <div className=\"dropdown is-hoverable is-right\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.fetchingParents ? ' is-loading':'')}>\n                                <span>Export</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleExportNode}>\n                                  Node to Clipboard\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleExportChildren}>\n                                  Children to ClipBoard\n                                </a>\n                                \n                                {\n                                  (this.state.parentNodes || []).map(parentNode=>{\n                                    return (\n                                      <a key={parentNode._id} className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(parentNode.data.learn)}>\n                                        To LocalStorage: <strong>{parentNode.data ? parentNode.data.learn:'missing'}</strong>\n                                      </a>\n                                    )\n                                  })\n                                }\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          \n                          {\n                            !this.state.saving ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Saving...\n                              </a>\n                            </p>\n                          }\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div style={{flex:'0 1 auto'}}>\n                <div className=\"tabs\">\n                  <ul>\n                    {\n                      mainTabs.map(tab=>(\n                        <li \n                          key={tab[0]}\n                          className={this.state.mainTab == tab[0] ? \"is-active\":''}\n                          onClick={e=>this.handleChangeMainTab(tab[0])}\n                        ><a>{tab[1]}</a></li>\n                      ))\n                    }\n                  </ul>\n                </div>\n              </div>\n              \n              <div \n                className=\"\" \n                style={{flex:'1 1 auto'}}\n                ref={r=>this.parentRef=r}\n                >\n                <div \n                  style={{height: this.state.aceHeight+'px', position: 'relative'}} \n                  >\n                        \n                  <AceEditor\n                    ref={r=>this.aceRef=r}\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={value}\n                    onChange={v=>{\n                      if(this.state.mainTab == '__ALL__'){\n                        // if(this.state.schema.type == 'object'){\n                        //   this.props.setEditState('data', v)\n                        // } else {\n                        //   // raw\n                          this.props.setEditState('data', v)\n                        // }\n                      } else {\n                        let newObj = {};\n                        newObj[this.state.mainTab] = v;\n                        // console.log('onchangedata:', data, this.props.editState.fields.data);\n                        let newData = Object.assign({},data,newObj)\n                        this.props.setEditState('data', JSON.stringify(newData));\n                      }\n                    }}\n                    name=\"UNIQUE_ID_OF_DIV2\"\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    onLoad={editor=>{\n                      editor.getSession().setUseWrapMode(true);\n                    }}\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      showPrintMargin: false,\n                      enableSnippets: true,\n                      behavioursEnabled: false,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                  \n                </div>\n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      mycomponent = universe.withEditManager(mycomponent,{\n        editProp: 'node',\n        fields: ['type','data'],\n        fieldConvertServerOnceFunc: {\n          data: v=>{\n            return JSON.stringify(v,null,2)\n          }\n        },\n        fieldConvertServerFunc: {\n          // tmpData: v=>{\n          //   if(v){\n      \n          //   }\n          //   return v;\n          // }\n          // data: v=>{\n          //   // jsSchema\n          //   // console.log('NewServerData:', v);\n          //   if(v instanceof String){\n          //     return v;\n          //   }\n          //   return JSON.stringify(v);\n          //   // return JSON.stringify({\n          //   //   data: v // necessary to do this to retain correct types? \n          //   // },null,2)\n          // }\n        },\n        fieldCompareFunc: {\n          // uri: (prev, next)=>{\n          //   console.log('URI compare!:', prev, next);\n          //   return prev === next;\n          // }\n        }\n      });\n\n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512074702259,"updatedAt":1513222330910,"parent":{"_id":"5a1e554fdd301d7ef14ea6f5","nodeId":"5a1df9c06e69417096b3da88","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"name":"react components"},"active":true,"createdAt":1511937359089,"updatedAt":1512967316605},"nodes":[]}]},{"_id":"5a1efd9edd301d7ef14eabcc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980446218,"updatedAt":1511980464263,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a1efd9edd301d7ef14eabd4","nodeId":"5a1efd9edd301d7ef14eabcc","type":"text_tag:0.0.1:local:239fj23","data":{"text":"run_action_sequence: This is for handling a sequence of actions!"},"active":true,"createdAt":1511980446514,"updatedAt":null,"parent":{"_id":"5a1efd9edd301d7ef14eabcc","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980446218,"updatedAt":1511980464263},"nodes":[]},{"_id":"5a1efd9edd301d7ef14eabdc","nodeId":"5a1efd9edd301d7ef14eabcc","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"run_action_sequence:0.0.1:local:293fh8239hsdf23f"},"active":true,"createdAt":1511980446794,"updatedAt":null,"parent":{"_id":"5a1efd9edd301d7ef14eabcc","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980446218,"updatedAt":1511980464263},"nodes":[]},{"_id":"5a1efd9fdd301d7ef14eabe4","nodeId":"5a1efd9edd301d7ef14eabcc","type":"code:0.0.1:local:32498h32f2","data":{"key":"527d0a3f-016d-4215-9f40-94416eb374a0","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // return resolve({\n      //   multiple: 'todo: run multiple actions in sequence!'\n      // });\n      \n      // Should be piping information?? \n      // - just looping for now, expecting to store info in the cache, I guess?? \n      let actionResponses = [];\n      let continueActions = true;\n      for(let INPUT_data_idx in INPUT.data.actions){\n        if(!continueActions){\n          continue;\n        }\n        let INPUT_data = INPUT.data.actions[INPUT_data_idx];\n        \n        let x = 1; // this IS available in the filterNode function below!? \n        \n        let nodes = await universe.searchMemory({\n          filter: {\n            // sqlFilter: {\n            //   type: INPUT.type,\n            // },\n            // function for returning data from the Node, after filtering a bit \n            // - includes both the Node, and Nodes with nodeId (pointers) \n            filterNodes: tmpNodes=>{\n              // this runs isolated, outside of the above context? (not sure) \n              return new Promise((resolve, reject)=>{\n                tmpNodes = tmpNodes.filter(tmpNode=>{\n                  // see if has a ChildNode matching a type \n                  \n                  // // must match action type \n                  // if(tmpNode.type != INPUT.data.matchActionType){\n                  //   return false;\n                  // }\n                  // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  if(tmpNode.type != INPUT_data.matchActionType){\n                    return false;\n                  }\n                  // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                  \n                  // // must have code to run! \n                  // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                  //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                  // });\n                  \n                  // if(!foundChildCode){\n                  //   return false;\n                  // }\n                  \n                  return true;\n                });\n                resolve(tmpNodes);\n              });\n            },\n          }\n        });\n        \n        // return resolve({\n        //   test: 'ok',\n        //   typeMatch: INPUT.data.matchActionType,\n        //   nodes,\n        //   INPUT,\n        //   SELF\n        // });\n        \n        if(nodes && nodes.length){\n          // found Node to run for action! \n          // - assuming only 1 piece of Code possible/available \n          \n          let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n          \n          // run in vm, and pass in the inputSchema Node! \n          // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n          let actionResult;\n          try {\n            actionResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode: INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              timeout: 25 * 1000\n            });\n          }catch(err){\n            // return resolve('FAILED action');\n            actionResponses.push({\n              error: true,\n              msg: 'Failed action',\n              err: (err || '').toString()\n            });\n            continueActions = false;\n            continue;\n          }\n          \n          // validate actionResult!\n          // - todo\n          \n          // adding actionResult to results output\n          // return resolve(actionResult);\n          actionResponses.push(actionResult);\n          \n        } else {\n          // no Node found for handling action :( \n            \n          // return resolve({ \n          //   error: 'No Nodes for action2'\n          // }); // + result);\n          actionResponses.push({ \n            action: INPUT_data,\n            error: 'No Nodes for action2'\n          });\n        }\n        \n      }\n      \n      // resolve all\n      resolve({\n        actionResponses\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1511980447080,"updatedAt":1513150315551,"parent":{"_id":"5a1efd9edd301d7ef14eabcc","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980446218,"updatedAt":1511980464263},"nodes":[]}]},{"_id":"5a1eff9ddd301d7ef14eac18","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980957252,"updatedAt":null,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a1eff9ddd301d7ef14eac20","nodeId":"5a1eff9ddd301d7ef14eac18","type":"text_tag:0.0.1:local:239fj23","data":{"text":"browser_startup"},"active":true,"createdAt":1511980957648,"updatedAt":1511981093768,"parent":{"_id":"5a1eff9ddd301d7ef14eac18","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980957252,"updatedAt":null},"nodes":[]},{"_id":"5a1eff9ddd301d7ef14eac28","nodeId":"5a1eff9ddd301d7ef14eac18","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"browser_startup:0.0.1:local:8831167ssd"},"active":true,"createdAt":1511980957979,"updatedAt":1511980980391,"parent":{"_id":"5a1eff9ddd301d7ef14eac18","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980957252,"updatedAt":null},"nodes":[]},{"_id":"5a1eff9edd301d7ef14eac30","nodeId":"5a1eff9ddd301d7ef14eac18","type":"code:0.0.1:local:32498h32f2","data":{"key":"d1a7d985-f012-4555-a881-b1cd09431775","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      let result = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'react_component:0.0.1:local:98912hd89',\n            data: {\n              internalId: 'MainComponent'\n            }\n          }\n        }\n      });\n      let componentNode = await universe.runNodeCodeInVM({\n        codeNode: result[0],\n        dataNode: {}\n      });\n      // let componentNode = await universe.runInVM(result[0],{});\n      \n      return resolve(componentNode);\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1511980958361,"updatedAt":1513150315937,"parent":{"_id":"5a1eff9ddd301d7ef14eac18","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511980957252,"updatedAt":null},"nodes":[]}]},{"_id":"5a1f0163dd301d7ef14eac64","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511981411837,"updatedAt":null,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a1f0164dd301d7ef14eac6c","nodeId":"5a1f0163dd301d7ef14eac64","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ping:pong"},"active":true,"createdAt":1511981412236,"updatedAt":1511981424024,"parent":{"_id":"5a1f0163dd301d7ef14eac64","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511981411837,"updatedAt":null},"nodes":[]},{"_id":"5a1f0164dd301d7ef14eac74","nodeId":"5a1f0163dd301d7ef14eac64","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"ping:0.0.1:local:239fh298fh239h23"},"active":true,"createdAt":1511981412583,"updatedAt":1511981454335,"parent":{"_id":"5a1f0163dd301d7ef14eac64","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511981411837,"updatedAt":null},"nodes":[]},{"_id":"5a1f0164dd301d7ef14eac7c","nodeId":"5a1f0163dd301d7ef14eac64","type":"code:0.0.1:local:32498h32f2","data":{"key":"525d1100-71ab-40fc-893e-02940e7b7211","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      resolve({\n        type: 'pong:0.0.1:local:8992389hfdg',\n        data: 'pong'\n      })\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1511981412939,"updatedAt":1513150316284,"parent":{"_id":"5a1f0163dd301d7ef14eac64","nodeId":"5a1df9c06e69417096b3da88","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1511981411837,"updatedAt":null},"nodes":[]}]},{"_id":"5a1f0e41dd301d7ef14ead00","type":"external_identity:0.0.1:local:8982f982j92","data":{"publicKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjLaSkRwS1kFemGs6xMjp\nyDOriloc8oBcd8ITt8tjsbvoToSM7DSyT68Mga1tjFBdxQkg/nseedTjW180nAKu\nbWliSvoDKTILzkE/eNxtNbuSNN715r5M/b/smkTPPb7Qer1Yva7EkN0T3fIIrrZP\ntPwX2fyJe04D/qKlS0bVdanR0iAdRAuHWhzznPszluwiKJItazZuAHkS0If7O+LA\nmwKYpUq9GzapkAujs08e+vVK5N34t9jghbhVR8LweuCUwWoOItvDLSOjfkWpTwqc\nutT7xqwcu+muPEm2zASdp65UraSmo91AZJOX8WohUPi4+UD9OoBNsHlq0sKrQiA7\n2QIDAQAB\n-----END PUBLIC KEY-----","commonName":"main"},"active":true,"createdAt":1511984705634,"updatedAt":1511984794013,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a1f0e41dd301d7ef14ead08","nodeId":"5a1f0e41dd301d7ef14ead00","type":"external_identity_connect_method:0.0.1:local:382989239hsdfmn","data":{"method":"http","connection":"http://localhost:7001/ai"},"active":true,"createdAt":1511984705989,"updatedAt":1512457738942,"parent":{"_id":"5a1f0e41dd301d7ef14ead00","nodeId":"5a1df9c06e69417096b3da88","type":"external_identity:0.0.1:local:8982f982j92","data":{"publicKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjLaSkRwS1kFemGs6xMjp\nyDOriloc8oBcd8ITt8tjsbvoToSM7DSyT68Mga1tjFBdxQkg/nseedTjW180nAKu\nbWliSvoDKTILzkE/eNxtNbuSNN715r5M/b/smkTPPb7Qer1Yva7EkN0T3fIIrrZP\ntPwX2fyJe04D/qKlS0bVdanR0iAdRAuHWhzznPszluwiKJItazZuAHkS0If7O+LA\nmwKYpUq9GzapkAujs08e+vVK5N34t9jghbhVR8LweuCUwWoOItvDLSOjfkWpTwqc\nutT7xqwcu+muPEm2zASdp65UraSmo91AZJOX8WohUPi4+UD9OoBNsHlq0sKrQiA7\n2QIDAQAB\n-----END PUBLIC KEY-----","commonName":"main"},"active":true,"createdAt":1511984705634,"updatedAt":1511984794013},"nodes":[]}]},{"_id":"5a23882a57eb5ba9802c3cf1","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512278058441,"updatedAt":1512278184330,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a23882a57eb5ba9802c3cf9","nodeId":"5a23882a57eb5ba9802c3cf1","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512278058802,"updatedAt":null,"parent":{"_id":"5a23882a57eb5ba9802c3cf1","nodeId":"5a1df9c06e69417096b3da88","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512278058441,"updatedAt":1512278184330},"nodes":[]},{"_id":"5a23882b57eb5ba9802c3d01","nodeId":"5a23882a57eb5ba9802c3cf1","type":"code:0.0.1:local:32498h32f2","data":{"key":"b8c79f0f-7d4a-4398-a193-1b9477c9550f","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      var key = new universe.rsa({b: 512});\n      key.generateKeyPair(512, 65537); // 2048\n      \n      const keypair = {\n        private: key.exportKey('pkcs8-private-pem'), \n        public: key.exportKey('pkcs8-public-pem'),\n      }\n      \n      let NodeToSave = {\n        type: 'identity_private:0.0.1:local:3298f2j398233',\n        data: keypair\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      \n      resolve({\n        savedNode\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512278059146,"updatedAt":1513150316899,"parent":{"_id":"5a23882a57eb5ba9802c3cf1","nodeId":"5a1df9c06e69417096b3da88","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512278058441,"updatedAt":1512278184330},"nodes":[]},{"_id":"5a23882b57eb5ba9802c3d09","nodeId":"5a23882a57eb5ba9802c3cf1","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: create a new RSA keypair and store locally"},"active":true,"createdAt":1512278059633,"updatedAt":null,"parent":{"_id":"5a23882a57eb5ba9802c3cf1","nodeId":"5a1df9c06e69417096b3da88","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512278058441,"updatedAt":1512278184330},"nodes":[]},{"_id":"5a23882c57eb5ba9802c3d11","nodeId":"5a23882a57eb5ba9802c3cf1","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512278060002,"updatedAt":null,"parent":{"_id":"5a23882a57eb5ba9802c3cf1","nodeId":"5a1df9c06e69417096b3da88","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512278058441,"updatedAt":1512278184330},"nodes":[]},{"_id":"5a23882c57eb5ba9802c3d19","nodeId":"5a23882a57eb5ba9802c3cf1","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512278060336,"updatedAt":null,"parent":{"_id":"5a23882a57eb5ba9802c3cf1","nodeId":"5a1df9c06e69417096b3da88","type":"create_identity:0.0.1:local:34234234h2k","data":null,"active":true,"createdAt":1512278058441,"updatedAt":1512278184330},"nodes":[]}]},{"_id":"5a2444fdbb0cb7db7ace9615","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1512326397582,"updatedAt":1512338492822,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a2444febb0cb7db7ace9625","nodeId":"5a2444fdbb0cb7db7ace9615","type":"code:0.0.1:local:32498h32f2","data":{"key":"619427af-8b4b-4c58-975f-9cc95f55d6f6","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'new':\n          console.log('Getting new rsa instance');\n          return resolve({\n            type: 's....',\n            data: new universe.rsa(inputOpts)\n          })\n          \n        \n        case 'sign':\n        \n          let stringToSign = inputOpts.stringToSign;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getPrivate',\n              options: {}\n            }\n          });\n          \n          console.log('MY privateIdentity NODE', MyPrivateIdentity);\n          \n          // // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          // let myPublicKey = MyPrivateIdentity.data.public;\n          \n          // let IdentityNode = await getPrivateIdentity();\n          let privateKey = MyPrivateIdentity.data.private;\n\n          let key1 = new universe.rsa(privateKey);\n          let signed = key1.sign(stringToSign);\n\n          return resolve({\n            type: 'string:0.0.1:local:289hf329h93',\n            data: signed.toString('base64')\n          });\n\n          \n        \n        case 'verify':\n          console.log('Verifying', inputOpts);\n          let ChallengeVerifyNode = inputOpts.ChallengeVerifyNode;\n          let key2 = new universe.rsa(ChallengeVerifyNode.data.publicKey);\n\n          let verified = key2.verify(ChallengeVerifyNode.data.challenge, ChallengeVerifyNode.data.solution, undefined, 'base64'); // todo\n\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: verified\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512326398320,"updatedAt":1513150317215,"parent":{"_id":"5a2444fdbb0cb7db7ace9615","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1512326397582,"updatedAt":1512338492822},"nodes":[]},{"_id":"5a2444febb0cb7db7ace962d","nodeId":"5a2444fdbb0cb7db7ace9615","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: rsa"},"active":true,"createdAt":1512326398733,"updatedAt":1512442577600,"parent":{"_id":"5a2444fdbb0cb7db7ace9615","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1512326397582,"updatedAt":1512338492822},"nodes":[]},{"_id":"5a2444ffbb0cb7db7ace9635","nodeId":"5a2444fdbb0cb7db7ace9615","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512326399112,"updatedAt":1512331224752,"parent":{"_id":"5a2444fdbb0cb7db7ace9615","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1512326397582,"updatedAt":1512338492822},"nodes":[]}]},{"_id":"5a249b4ad28fbde9bfb11c2a","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1512348490622,"updatedAt":1512348532494,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a249b4bd28fbde9bfb11c3a","nodeId":"5a249b4ad28fbde9bfb11c2a","type":"code:0.0.1:local:32498h32f2","data":{"key":"e7af1532-eb2b-45f6-8673-79199855e487","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'talk':\n        case 'send':\n            \n            // inputOpts\n          \n          let { ExternalIdentityNode, RequestNode } = inputOpts;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let nodeResponse = await universe.loadAndRunCapability('Request',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'make',\n              options: {\n                ExternalIdentityNode,\n                RequestNode\n              }\n            }\n          });\n          \n          return resolve(nodeResponse);\n            \n          // let nodeResponse = await universe. TalkToSecond({\n          //   ExternalIdentityNode: INPUT,\n          //   InputNode: {\n          //     type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //     data: {\n          //       actions: [\n          //         {\n          //           matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //           dataForAction: {\n          //             type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //             data: {\n          //               matchFunctionNode: {\n          //                 // query here!\n          //                 // action_pointer:0.0.1:local:238972ncr\n          //                 type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                 data: {\n          //                   code: codeSearchTemplate\n          //                 }\n          //               },\n          //               // expected/allowed schemas for return \n          //               // outputSchemas: [\n          //               //   'query_result:0.0.1:local:32490usfj23o23f',\n          //               //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //               // ]\n          //             }\n          //           }\n          //         }\n          //       ]\n                \n          //     }\n          //   }\n          // });\n          \n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512348491857,"updatedAt":1513150317587,"parent":{"_id":"5a249b4ad28fbde9bfb11c2a","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1512348490622,"updatedAt":1512348532494},"nodes":[]},{"_id":"5a249b4cd28fbde9bfb11c4a","nodeId":"5a249b4ad28fbde9bfb11c2a","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: TalkToSecond"},"active":true,"createdAt":1512348492839,"updatedAt":1512442600527,"parent":{"_id":"5a249b4ad28fbde9bfb11c2a","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1512348490622,"updatedAt":1512348532494},"nodes":[]},{"_id":"5a249b4ed28fbde9bfb11c5a","nodeId":"5a249b4ad28fbde9bfb11c2a","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512348494062,"updatedAt":null,"parent":{"_id":"5a249b4ad28fbde9bfb11c2a","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1512348490622,"updatedAt":1512348532494},"nodes":[]}]},{"_id":"5a24b18d86f2f4eecbab3ac8","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1512354189429,"updatedAt":1512354205894,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a24b18e86f2f4eecbab3ad7","nodeId":"5a24b18d86f2f4eecbab3ac8","type":"code:0.0.1:local:32498h32f2","data":{"key":"434cf555-082f-485d-b0b5-df63cc1e34f1","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, authToken } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      // return resolve({\n      //   INPUT\n      // });\n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      \n      // Need to create a local Identity, and authenticate with the remote Second to Learn from \n      // - uses a constant value (token) from the remote Second! \n      let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'getPrivate',\n          options: {}\n        }\n      });\n      \n      console.log('MY privateIdentity NODE', MyPrivateIdentity);\n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      // ExternalIdentityNode\n      console.log('Making ExternalInitialResponseNodeFull request');\n      let ExternalInitialResponseNodeFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedInitiateIdentifyNode\n          }\n        }\n      });\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      console.log('ExternalInitialResponseNodeFull',ExternalInitialResponseNodeFull);\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      console.log('Verifying challenge I sent', ExternalInitialResponseNode, ExternalIdentityNode);\n      let verified = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'verify',\n          options: {\n            ChallengeVerifyNode:{\n              type: '...',\n              data: {\n                challenge: newChallenge,\n                solution: ExternalInitialResponseNode.data.solution,\n                publicKey: ExternalIdentityNode.data.publicKey\n              }\n            }\n          }\n        }\n      });\n      \n      console.log('Local Verified response:', verified);\n      \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      \n      console.log('Signing remote challenge', ExternalInitialResponseNode);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign: ExternalInitialResponseNode.data.challenge\n          }\n        }\n      });\n      \n      console.log('Local SignedNode response:', SignedNode);\n      \n      \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      let privateConnectMethod = universe.lodash.find(MyPrivateIdentity.nodes, { type: 'private_identity_connect_method:0.0.1:local:9081j29h3' });\n      \n      console.log('AFter Search');\n      \n      if(privateConnectMethod){\n        console.log('Has privateConnectMethod!!!!', privateConnectMethod);\n      } else {\n        console.log('NO privateConnectMethod???');\n      }\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting an encrypted token back for later auth requests \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data, // base64 string \n          connectMethod: privateConnectMethod ? privateConnectMethod.data : undefined\n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      \n      console.log('Making ExternalTokenResponseFull request with WrappedTokenNode', WrappedTokenNode);\n      let ExternalTokenResponseFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedTokenNode\n          }\n        }\n      });\n      \n      console.log('Local ExternalTokenResponseFull response:', ExternalTokenResponseFull);\n      \n      \n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      console.log('AT IDENTIFY STAGE 2');\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode,\n            ok: true\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512354190275,"updatedAt":1513150317937,"parent":{"_id":"5a24b18d86f2f4eecbab3ac8","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1512354189429,"updatedAt":1512354205894},"nodes":[]},{"_id":"5a24b18f86f2f4eecbab3ae5","nodeId":"5a24b18d86f2f4eecbab3ac8","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: IdentifyInitiate"},"active":true,"createdAt":1512354191390,"updatedAt":1512442608953,"parent":{"_id":"5a24b18d86f2f4eecbab3ac8","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1512354189429,"updatedAt":1512354205894},"nodes":[]},{"_id":"5a24b19086f2f4eecbab3af9","nodeId":"5a24b18d86f2f4eecbab3ac8","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512354192424,"updatedAt":null,"parent":{"_id":"5a24b18d86f2f4eecbab3ac8","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1512354189429,"updatedAt":1512354205894},"nodes":[]}]},{"_id":"5a24b3fb86f2f4eecbab3b69","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1512354811908,"updatedAt":1512679781074,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a24b3fc86f2f4eecbab3b78","nodeId":"5a24b3fb86f2f4eecbab3b69","type":"code:0.0.1:local:32498h32f2","data":{"key":"e830f0fd-5313-48a7-8518-c431c5b4c7bb","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'createLocal': // should only happen once! \n          console.log('Create a new Local Private Identity');\n              \n          var key = new universe.rsa({b: 512});\n          key.generateKeyPair(512, 65537); // 2048\n          \n          const keypair = {\n            private: key.exportKey('pkcs8-private-pem'), \n            public: key.exportKey('pkcs8-public-pem'),\n          }\n          \n          let NodeToSave = {\n            type: 'identity_private:0.0.1:local:3298f2j398233',\n            data: keypair\n          }\n          \n          // save Node to memory\n          let savedNode = await universe.newNode(NodeToSave);\n          \n          // save the connectMethod as well \n          let connectionUrl = 'http://localhost:9999';\n          if(universe.env.HEROKU_APP_NAME){\n            connectionUrl = `http://${universe.env.HEROKU_APP_NAME}.herokuapp.com/ai`; \n          }\n          if(universe.env.PUBLIC_HOST == 'ngrok.io'){\n            connectionUrl = `http://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n          }\n          if(universe.env.PUBLIC_HOST == 'herokuapp.com'){\n            connectionUrl = `http://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n          }\n          console.log('CONNECTION_URL:', connectionUrl);\n          \n          let childNodeToSave = {\n            nodeId: savedNode._id,\n            type: 'private_identity_connect_method:0.0.1:local:9081j29h3',\n            data: {\n              method: 'http',\n              connection: connectionUrl\n            }\n          }\n          \n          let savedChildNode = await universe.newNode(childNodeToSave);\n          // delete savedChildNode.parent; // kill recursion\n          savedNode.nodes = [savedChildNode];\n          \n          return resolve(savedNode);\n          \n        case 'getPrivate':\n        \n          let privateNodes;\n          try{\n            privateNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'identity_private:0.0.1:local:3298f2j398233'\n                }\n              }\n            });\n            if(!privateNodes.length){\n              throw \"No private identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no identity'\n            });\n          }\n\n          let IdentityNode = privateNodes[0];\n          return resolve(IdentityNode);\n          \n        case 'getExternal':\n        \n          let externalNodes;\n          try{\n            externalNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: inputOpts.publicKey\n                  }\n                }\n              }\n            });\n            if(!externalNodes.length){\n              throw \"No external identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no external identity match'\n            });\n          }\n\n          let ExternalIdentityNode = externalNodes[0];\n          return resolve(ExternalIdentityNode);\n          \n          \n        case 'registerOnChain':\n          let remoteCreated = await universe.createAddressForIdentity(inputOpts.words, inputOpts.publicKey, inputOpts.connection)\n          return resolve(remoteCreated);\n          \n          \n        case 'saveExternal':\n          // Duplicate publicKeys get updated! \n          \n          console.log('saveExternal inputOpts', inputOpts);\n          \n          let externalNodes3 = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n                }\n              }\n            }\n          });\n          \n          let NodeToSave3 = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n            }\n          }\n          \n          if(externalNodes3 && externalNodes3.length){\n            // exists!\n            NodeToSave3._id = externalNodes3[0]._id;\n          }\n          \n          // external_identity:0.0.1:local:8982f982j92\n          // external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // save Node to memory\n          let savedNode3;\n          if(NodeToSave3._id){\n            savedNode3 = await universe.updateNode(NodeToSave3);\n          } else {\n            savedNode3 = await universe.newNode(NodeToSave3);\n          }\n          \n          // save/update the connectMethod as well \n          if(inputOpts.ExternalIdentityNode.nodes){\n            let childNodeToSave3 = {\n              nodeId: savedNode3._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: inputOpts.ExternalIdentityNode.nodes[0].data\n            }\n            \n            let savedChildNode3;\n            if(externalNodes3 && externalNodes3.length && externalNodes3[0].nodes){\n              childNodeToSave3._id = externalNodes3[0].nodes[0]._id;\n              savedChildNode3 = await universe.updateNode(childNodeToSave3);\n            } else {\n              savedChildNode3 = await universe.newNode(childNodeToSave3);\n            }\n          }\n          \n          console.log('Saved External, locally');\n          \n          let NewExternalNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getExternal',\n              options: {\n                publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n              }\n            }\n          });\n          \n          console.log('Got New/UpdatedExternalNode', NewExternalNode);\n          \n          return resolve(NewExternalNode);\n          \n          \n        \n        case 'getAddressForWords':\n          // inputOpts.words = String;\n          // transform to \"string[space]string[space]string[space]\" format \n          let remoteValue = universe.lodash.compact(inputOpts.words.split(' ')).join(' ');\n          // transform to wallet address \n          var hash = universe.bitcoin.crypto.sha256(remoteValue)\n          console.log('hash:', hash);\n          var d = universe.bigi.fromBuffer(hash)\n          console.log('d:', d);\n          var keyPair = new universe.bitcoin.ECPair(d)\n          var address = keyPair.getAddress()\n          console.log('Remote Second Wallet Address', address);\n          return resolve({\n            type:'wallet_address:..',\n            data: address\n          })\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512354812646,"updatedAt":1513150318358,"parent":{"_id":"5a24b3fb86f2f4eecbab3b69","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1512354811908,"updatedAt":1512679781074},"nodes":[]},{"_id":"5a24b3fd86f2f4eecbab3b89","nodeId":"5a24b3fb86f2f4eecbab3b69","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Identity"},"active":true,"createdAt":1512354813574,"updatedAt":1512442617459,"parent":{"_id":"5a24b3fb86f2f4eecbab3b69","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1512354811908,"updatedAt":1512679781074},"nodes":[]},{"_id":"5a24b3fe86f2f4eecbab3b9a","nodeId":"5a24b3fb86f2f4eecbab3b69","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512354814647,"updatedAt":null,"parent":{"_id":"5a24b3fb86f2f4eecbab3b69","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1512354811908,"updatedAt":1512679781074},"nodes":[]}]},{"_id":"5a24c03386f2f4eecbab3d8c","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1512357939748,"updatedAt":1512357949948,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a24c03486f2f4eecbab3d9c","nodeId":"5a24c03386f2f4eecbab3d8c","type":"code:0.0.1:local:32498h32f2","data":{"key":"90bd3427-5301-415d-ac12-c3f9a3c530d0","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'make':\n        \n          console.log('Make Request inputOpts', inputOpts);\n          \n          // Make a request to an external Second \n          // inputOpts: {\n          //   ExternalIdentityNode, // must include connect_method\n          //   RequestNode: InitiateIdentifyNode\n          // }\n          \n          // let ExternalRequestNode = inputOpts.ExternalIdentityNode;\n\n          // ExternalIdentityNode needs to have a NodeChild w/ a connect_method \n          let connectNode = universe.lodash.find(inputOpts.ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n          if(!connectNode){\n            console.error('Missing ConnectNode!');\n            return reject({\n              type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n              data: {\n                str: 'Missing existing ExternalIdentity connect_method child!'\n              }\n            })\n          }\n\n          console.log('Making external request');\n\n          // make web request\n          // - just passing through, assume any Auth is already included? \n          let response = await universe.directToSecond({\n            url: connectNode.data.connection,\n            RequestNode: inputOpts.RequestNode,\n            // method: 'post',\n            // url: connectNode.data.connection, // expecting URL at first! \n            // body: ExternalRequestNode.data.RequestNode,\n            // json: true\n          })\n\n          // ONLY returning a \"second\" response! (no other URL is allowed besides this, for now) \n          return resolve(response.secondResponse);\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512357940934,"updatedAt":1513150318798,"parent":{"_id":"5a24c03386f2f4eecbab3d8c","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1512357939748,"updatedAt":1512357949948},"nodes":[]},{"_id":"5a24c03686f2f4eecbab3dad","nodeId":"5a24c03386f2f4eecbab3d8c","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Request"},"active":true,"createdAt":1512357942403,"updatedAt":1512442623981,"parent":{"_id":"5a24c03386f2f4eecbab3d8c","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1512357939748,"updatedAt":1512357949948},"nodes":[]},{"_id":"5a24c03886f2f4eecbab3dbe","nodeId":"5a24c03386f2f4eecbab3d8c","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512357944120,"updatedAt":null,"parent":{"_id":"5a24c03386f2f4eecbab3d8c","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1512357939748,"updatedAt":1512357949948},"nodes":[]}]},{"_id":"5a2747cb9bd7021a55d5b4e9","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyActAsInternalUser"},"active":true,"createdAt":1512523723198,"updatedAt":1512523739714,"parent":{"_id":"5a1df9c06e69417096b3da88","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"browser_developer"},"active":true,"createdAt":1511913920224,"updatedAt":1512976649521},"nodes":[{"_id":"5a2747cc9bd7021a55d5b4f9","nodeId":"5a2747cb9bd7021a55d5b4e9","type":"code:0.0.1:local:32498h32f2","data":{"key":"febc8408-1b4a-44cd-b4d0-441690dc8232","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('Starting ActAs Capability');\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       internalUserPassphrase\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, internalUserPassphrase } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      \n      // Upgrades token (gets a new token for ExternalIdentityNode, updates local memory) \n      //- adds InternalUser for remote \n      \n      \n      // Get local ExternalIdentity \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      \n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      \n      // TalkToSecond (runs sequence of auth w/ token, then upgrade) \n      console.log('Token FOR ActAs:', ExternalIdentityNode.data.token, ExternalIdentityNode);\n      let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'send',\n          options: {\n            ExternalIdentityNode,\n            RequestNode: {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                        \n                  {\n                    matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                    dataForAction: {\n                      type: 'string:...',\n                      data: ExternalIdentityNode.data.token\n                    }\n                  },\n                  \n                  {\n                    matchActionType: 'identify_token_upgrade_to_internal_user:0.0.1:local:9281198u',\n                    dataForAction: {\n                      type: 'user_passphrase:0.01...',\n                      data: {\n                        passphrase: internalUserPassphrase\n                      }\n                    }\n                  }\n                ]\n                \n              }\n            }\n          }\n        }\n      });\n      \n      console.log('ActAs Response:', response);\n      \n      // expecting type: upgrade_token_response:0.0.1:local:289fh2389h23sfsvds\n      \n      let tokenResponse = response.data.actionResponses[1];\n      if(tokenResponse.type != 'upgrade_token_response:0.0.1:local:289fh2389h23sfsvds'){\n        console.error('Failed Identity Upgrade to InternalUser');\n        return reject({\n          msg: 'Failed Identity Upgrade to InternalUser', \n          error: true\n        })\n      }\n      let newToken = tokenResponse.data.token;\n      \n      // Update/save local ExternalIdentityNode with new token \n      ExternalIdentityNode.data.token = newToken;\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      \n      return resolve({\n        type: 'identity_upgrade_finish:0.0.1:local:981h3001j3',\n        data: {\n          updatedExternalIdentityNode,\n          newToken\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512523724116,"updatedAt":1513150324908,"parent":{"_id":"5a2747cb9bd7021a55d5b4e9","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyActAsInternalUser"},"active":true,"createdAt":1512523723198,"updatedAt":1512523739714},"nodes":[]},{"_id":"5a2747cc9bd7021a55d5b50a","nodeId":"5a2747cb9bd7021a55d5b4e9","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: IdentifyActAsInternalUser"},"active":true,"createdAt":1512523724997,"updatedAt":1512523757831,"parent":{"_id":"5a2747cb9bd7021a55d5b4e9","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyActAsInternalUser"},"active":true,"createdAt":1512523723198,"updatedAt":1512523739714},"nodes":[]},{"_id":"5a2747ce9bd7021a55d5b51b","nodeId":"5a2747cb9bd7021a55d5b4e9","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512523726041,"updatedAt":null,"parent":{"_id":"5a2747cb9bd7021a55d5b4e9","nodeId":"5a1df9c06e69417096b3da88","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyActAsInternalUser"},"active":true,"createdAt":1512523723198,"updatedAt":1512523739714},"nodes":[]}]}]